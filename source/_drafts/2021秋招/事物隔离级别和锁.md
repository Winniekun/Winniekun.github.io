## 总结

整体总结[解决死锁之路](https://www.aneasystone.com/archives/2017/10/solving-dead-locks-one.html) 这篇文章，主要阐述的是隔离型和锁、MVCC的关系

## 什么是事物

事物数据库的一个特性，也是却别普通的文件系统的重要特性之一，可以有一条简单的sql构成，也可以由一组复杂的sql组成，同时事物也是是访问并修改数据库中数据的基本单位。在事物中，所有命令要么全部执行成功，要么就全部都不执行，这是事物的目的。事物有四大特性：原子性（Atomicity）、一致性（consisstency）、隔离型（isolation）、持久性（durability）。

## 隔离级别

在了解隔离级别和锁的关系之前，应该先明确事物为什么会有不同的隔离级别，是为了解决什么问题的。多个事物在并发的情况下，会出现一些常见的问题

**一个事物写、一个事物读出现的问题**

1. 脏读
2. 不可重复读
3. 幻读

**两个事物的写**

1. 提交覆盖
2. 回滚覆盖

所以，隔离级别出现就是为了解决如上的多并发情况下对数据库的操作而出现的问题。最简单的方式就是无论是读还是写操作都对数据进行加锁。这样就能完美的解决了这些问题。也就是**序列化**隔离级别，在序列化隔离级别下，可以保证事物的安全执行，数据库的一致性的一保证，但是降低了事物的并发性能。

为了调和事务的安全性和性能之间的冲突，适当的降低隔离级别，可以有效的提高数据库的并发性能。于是便有了四种不同的隔离级别：

1. 读未提交
   1. 一个事务还没提交时，它做的变更就能被别的事务看到，所以无法杜绝脏读、不可重复读、幻读的问题
2. 读已提交（RC）
   1. 一个事物提交之后，它做的变更才会被其他事物看到，无法杜绝不可重复读、幻读问题
3. 可重复读（RR）
   1. 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，无法杜绝幻读问题
4. 序列化

## 隔离级别的实现

上述的四种隔离级别是SQL标准中通用的概念，但是对于不同的数据库产品，对这些标准的实现也不尽相同。譬如MySQL在RR的隔离级别下，会通过多版本快照读和Next-key Lock解决幻读的问题。

### 正常情况下隔离级别的实现

首先，隔离级别和锁是两个不同的概念。隔离级别是SQL中的规范标准，锁是去实现这一标准的方式之一。使用锁实现不同的隔离级别我们称之为**基于锁的并发控制**。具体的实现是通过读写操作施加不同锁以及控制锁放锁的时机

1. 读未提交
   - 事物的读不阻塞其他事物的读写、事物的写不阻塞其他事物的读，但是阻塞写，所以可以通过对写操作添加**持续X锁（排他/写锁）**，对读操作不添加锁即可。
2. 读已提交
   - 事物的读不阻塞其他事物的读写、事物的写阻塞其他事物的读和写，所以可以通过对写操作添加**持续X锁（排他/写锁）**，对读操作添加**临时S（共享/读）锁**
3. 不可重复读
   - 事物的读不阻塞其他事物饿读，但是阻塞其他事物的写，同时事物的写阻塞其他事物的读和写，所以可以通过对事物的写添加**持续X锁**，读添加**持续的S锁**
4. 序列化
   - 行锁无法做到，直接使用表锁级别添加对应的读写锁

### MySQL中隔离级别的实现

基于锁来实现事务隔离，解决了并发的读读的问题，但是对于并发的读写还是冲突的，写时不能读，读时不能写，当读写操作都很频繁时，数据库的并发性将大大降低，针对这种场景，MVCC 技术应运而生。MVCC 的全称叫做 **Multi-Version Concurrent Control（多版本并发控制）**， InnoDb 会为每一行记录增加几个隐含的**辅助字段**，（实际上是 3 个字段：一个隐式的 ID 字段，一个事务 ID，还有一个回滚指针），事务在写一条记录时会将其拷贝一份生成这条记录的一个原始拷贝，写操作同样还是会对原记录加锁，但是读操作会读取未加锁的新记录，这就保证了读写并行。要注意的是，生成的新版本其实就是 **undo log**，它也是实现事务回滚的关键技术。通过MVCC，将数据库从原先的只有读读之间可以并发，读写、写读、写写都要阻塞。变成了出了写写之间会阻塞，其他三种操作均不会阻塞。

需要注意的是不同隔离级别下，读的方式也是有所区别的。在**read uncommit** 隔离级别下，每次都是读取最新版本的记录，所以不能用 MVCC 的多版本，而**serializable**隔离级别每次读取操作都会为记录加上读锁，也和 MVCC 不兼容，所以只有 RC 和 RR 这两个隔离级别才有 MVCC。

1. 读已提交
   1. 读取记录的最新版本，如果该记录被锁住，则读取该记录最新的一次快照
2. 可重复读
   1. 读取该记录事物开始时的那个版本

虽然这两种隔离级别下，读取的方式不同，但读取的都是快照数据，并不会被其他操作阻塞，我们将这种读操作称之为**快照读**

除了快照读，还有一个种读取方式，称之为**当前读**，这种读操作不再是读取数据的快照版本，而是数据的最新版本，并会对数据加锁，根据加锁的不同，又分如下情况：

- SELECT ... LOCK IN SHARE MODE：加 S 锁
- SELECT ... FOR UPDATE：加 X 锁
- INSERT / UPDATE / DELETE：加 X 锁

同时，当前读在RC、RR级别下，具体锁的类型也不同，RC只加记录锁、RR除了加**记录锁**以外，还会添加**间隙锁**

总而言之，对于MySQL种，不同的隔离级别的实现如下：

|          | 快照读               | 当前读                     |
| -------- | -------------------- | -------------------------- |
| 读未提交 |                      |                            |
| 读已提交 | 读取最新一一份快照   | 读取最新版本+记录锁        |
| 可重复读 | 读取事物开始时的快照 | 读取最新版本+记录锁+间隙锁 |
| 序列化   |                      |                            |

MVCC 诞生的原因就是改善基于锁的方式带来的效率低的问题。使得读写之间互不阻塞，提高了单纯的基于锁的并发效率。



