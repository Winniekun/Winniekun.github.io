# 操作系统高频问题

## 一些不太顺嘴的知识点儿

<details>
<summary>什么是内核态和用户态</summary>
<detail>现代处理器架构一般允许CPU在至少两种不同的状态下运行：用户态、内核态。执行硬件指令可使CPU在两种状态下进行来回切换，与之相对应的就是将虚拟内存划分为用户空间、内核空间部分。在用户态下，运行时，CPU只能访问被标记为用户空间的内存。直接访问内核空间会引发硬件异常。当运行于内核态时，CPU既能访问用户态空间，又能访问内核态空间。同时当且仅当处理在内核态运行时，才能执行某些特定的操作，譬如访问内存管理硬件、I/O处理等。所以将操作系统置于内核空间，这样确保了用户进程不能访问内核指令和数据结构，也不能执行不利于系统运行的操作</detail>
</details>

## 进程管理

### 进程的数据构

1. PCB
2. 程序段
3. 数据段

### 进程和线程的区别

<details>
<summary>进程的切换为什么开销大</summary>
<detail>进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</detail>
</details>

**进程是程序的动态表现。** 一个程序进行起来后，会使用很多资源，比如使用寄存器，内存，文件等。每当切换进程时，必须要考虑保存当前进程的状态。状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开的文件描述符的集合，这个状态叫做上下文（Context）。可见，想要切换进程，保存的状态还不少。不仅如此，由于虚拟内存机制，进程切换时需要**刷新TLB**并获取新的地址空间。

线程存在于进程中，一个进程可以有一个或多个线程。**线程是运行在进程上下文中的逻辑流**，这个线程可以独立完成一项任务。同样线程有自己的上下文，包括唯一的整数线程ID， 栈、栈指针、程序计数器、通用目的寄存器和条件码。**可以理解为线程上下文是进程上下文的子集。**

**TLB：**

<img src="https://i.loli.net/2021/04/19/vY6DXnBtzaKMELp.png" alt="image-20210419180752430" style="zoom: 50%;" />



### 进程的通讯方式

#### 信号

是Linux系统为了响应某些条件而产生的一个事件，由操作系统预先定义，接收到该信号的进程可以采取自定义的行为。类似"发布-订阅"的模式

#### 信号量

是一种特殊的变量，对信号量的操作都是原子性的，分为P、V操作，P将信号量-1（占用一个共享资源），V将信号量值+1（释放一个共享资源） 主要用来解决多进程、多线程之间的同步问题。

#### 管道

最为常见的是我们所熟悉的“｜”操作符和FIFO，用于在进程之间传递数据

管道操作符“｜”分割的每个命令都是独立的进程

各个进程的标准输出STDOUT，会作为下一个进程的标准输入STDIN

#### 共享内存

进程间本身的内存是相互隔离的，而共享内存机制相当于给两个进程开辟了一块二者均可访问的内存空间，这时，两个进程便可以共享一些数据了。但是，多进程同时占用资源会带来一些意料之外的情况，这时，我们往往会采用上述的信号量来控制多个进程对共享内存空间的访问。

#### 消息队列

#### socket

#### 孤儿进程和僵尸进程

1. 在Unix/Linux中，正常情况下，子进程是由父进程创建的，子父进程的运行属于异步的过程，父进程无法预测子进程到底什么时候结束，当一个进程完成他的工作终止之后，其父进程需要使用wait()、waitpid()系统调用来来获取子进程的终止状态。

2. 孤儿进程：父进程退出之后，但是其一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

3. 僵尸进程：一个子进程退出之后，父进程没有使用wait()、waitpid()方法调用来获取子进程的状态信息，就是使得子进程的描述符仍然存在于系统中。

   1. 概念

      它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间

   2. 危害

      1. 占用进程号，系统中所有能使用的进程号是有限的，占用内存

   3. 解决方式

      1. 如果父进程没有什么工作任务，可以kill掉父进程，然后使得僵尸进程变为孤儿进程，由init进程进行托管

#### 如何杀死进程

我们都知道，想要**在Linux中终止一个进程有两种方式，如果是前台进程可以使用Ctrl+C键进行终止；如果是后台进程，那么需要使用kill命令来终止。**（其实Ctrl+C也是kill命令）

**kill命令的格式：**

```shell
kill [参数] [进程号]
如：
kill 23422
kill -9 23422
```

**参数可选，进程号可以通过jps，ps， top等工具获取**

kill的命令参数有以下几种：

> -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
>
> -a 当处理当前进程时，不限制命令名和进程号的对应关系
>
> -p 指定kill 命令只打印相关进程的进程号，而不发送任何信号
>
> -s 指定发送信号
>
> -u 指定用户

##### kill -9 和 kill -15的区别

kill命令默认的信号就是15，首先来说一下这个默认的`kill -15`信号。

当使用`kill -15`时，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。

这时候，应用程序可以选择：

- 1、立即停止程序
- 2、释放响应资源后停止程序
- 3、忽略该信号，继续执行程序

因为`kill -15`信号只是通知对应的进程要进行”安全、干净的退出”，程序接到信号之后，退出前一般会进行一些”准备工作”，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。

但是，如果在”准备工作”进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。

这也就是为什么我们有的时候使用kill命令是没办法”杀死”应用的原因，因为**默认的kill信号是SIGTERM（15），而SIGTERM（15）的信号是可以被阻塞和忽略的。**

和`kill -15`相比，`kill -9`就相对强硬一点，系统会发出SIGKILL信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。

所以，**相比于`kill -15`命令，`kill -9`在执行时，应用程序是没有时间进行”准备工作”的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。**

##### Java是如何处理SIGTERM（15）的

我们都知道，在Linux中，Java应用是作为一个独立进程运行的，Java程序的终止运行是基于JVM的关闭实现的，JVM关闭方式分为3种：

> 正常关闭：当最后一个非守护线程结束或者调用了System.exit或者通过其他特定平台的方法关闭（接收到SIGINT（2）、SIGTERM（15）信号等）
>
> 强制关闭：通过调用Runtime.halt方法或者是在操作系统中强制kill（接收到SIGKILL（9）信号)
>
> 异常关闭：运行中遇到RuntimeException异常等。

### 线程的通讯方式

1. 锁同步的通讯机制
2. 信号量
3. 等待通知机制



## 内存管理

## 文件管理

## 常用命令

### top

![image-20210419160812017](https://i.loli.net/2021/04/19/aISQReCin4l7pUc.png)

1. 第一行（系统当前状况）
   1. 系统当前时间
   2. up 23 days 2:50 系统已经运行了23天又170分钟
   3. 当前活跃用户为1个
   4. load average : 0.05 0.02. 0.00 分别表示系统1分钟、5分钟、15分钟的负载情况，load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。
2. 第二行（进程信息）
   1. 共有多少个进程 83个
   2. 处于于行状态的有几个 1个
   3. 处于休眠状态的有几个 51个
   4. 处于停止状态的有几个0个
   5. 处于僵尸状态的有几个 0 个
3. 第三行 （CPU使用信息）
   1.  us 用户空间占用cpu比例
   2. sy 内核空间占用cpu比例
   3. ，，，
4. 第四行 (内存使用情况)
5. swap交换使用情况

具体信息包含：当前进程PID、父进程PID、所属用户、cpu利用率

#### top排查cpu高的问题

1. top查看top1的pid

2. 然后 top -Hp查看该进程的具体线程信息，定位出cpu使用最高的线程id

3. 使用jstack查看具体问题在哪一行

   1. jstack是16进制，所以需要转换一下

      ```shell
      jstack PID | grep -A 10 16进制线程ID
      ```

[top查看进程中的线程](https://blog.csdn.net/inuyashaw/article/details/55095545)

