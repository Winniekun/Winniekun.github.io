# Spring总结

以下是自己总结的一些关于Spring的知识点

## Bean的加载过程

![image-20210423131609601](https://i.loli.net/2021/04/23/xf2ntHdEXFlwLhG.png)

1. 实例化bean （==实例化==）
2. 将配置文件中配置的属性填充到刚刚创建的bean对象中
3. 检查 bean 对象是否实现了 Aware 一类的接口，如果实现了则把相应的依赖设置到 bean 对象中。比如如果 bean 实现了 BeanFactoryAware 接口，Spring 容器在实例化bean的过程中，会将 BeanFactory 容器注入到 bean 中。（==初始化==）
4. 调用BeanPostProcesser前置处理方法，postProcessBeforeInitialization(Object bean, String beanName)。（==初始化==）
5. 检查 bean 对象是否实现了 InitializingBean 接口，如果实现，则调用 afterPropertiesSet 方法。或者检查配置文件中是否配置了 init-method 属性，如果配置了，则去调用 init-method 属性配置的方法。（==初始化==）
6. 调用 BeanPostProcessor 后置处理方法，即 postProcessAfterInitialization(Object bean, String beanName)。我们所熟知的 AOP 就是在这里将 Adivce 逻辑织入到 bean 中的。（==初始化==）
7. 注册 Destruction 相关回调方法。
8. bean对象处于就绪状态，标识为可以使用了
9. 应用上下文被销毁，调用注册的 Destruction 相关方法。如果 bean 实现了 DispostbleBean 接口，Spring 容器会调用 destroy 方法。如果在配置文件中配置了 destroy 属性，Spring 容器则会调用 destroy 属性对应的方法

接下来着重看下第二步-设置对象的属性，如果是普通的属性（Integer、String等）可以直接设置，但如果是引用的话，也就BeanA需要依赖BeanB，这里就无法直接设置了，而是需要先去实例化B然后再设置给A

![image-20210423133802368](/Users/weikunkun/Library/Application Support/typora-user-images/image-20210423133802368.png)

### 循环依赖

<img src="https://i.loli.net/2021/04/23/74tOJsxPKwG3WN1.png" alt="image-20210423133839181" style="zoom:33%;" />

> IOC 容器在读到上面的配置时，会按照顺序，先去实例化 beanA。然后发现 beanA 依赖于 beanB，接在又去实例化 beanB。实例化 beanB 时，发现 beanB 又依赖于 beanA。如果容器不处理循环依赖的话，容器会无限执行上面的流程，直到内存溢出，程序崩溃。当然，Spring 是不会让这种情况发生的。在容器再次发现 beanB 依赖于 beanA 时，容器会获取 beanA 对象的一个早期的引用（early reference），并把这个早期引用注入到 beanB 中，让 beanB 先完成实例化。beanB 完成实例化，beanA 就可以获取到 beanB 的引用，beanA 随之完成实例化

#### 一些缓存的概念

```java
/** Cache of singleton objects: bean name --> bean instance */
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);

/** Cache of singleton factories: bean name --> ObjectFactory */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);

/** Cache of early singleton objects: bean name --> bean instance */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);
```

| 缓存                  | 用途                                                         |
| --------------------- | ------------------------------------------------------------ |
| singletonObjects      | 用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用 |
| earlySingletonObjects | 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖       |
| singletonFactories    | 存放 bean 工厂对象，用于解决循环依赖                         |

==**所谓的早起引用也就是原始的bean对象（尚未填充属性），也就是bean加载中的第一步（实例化）**==





对于循环依赖的解决，根据依赖注入的方式不同，解决方式不同

1. 依赖靠构造器方式注入

   1. 无法处理，Spring会直接报循环依赖异常

      构造 BeanA 时需要 BeanB 作为构造器参数，此时 Spring 容器会先实例化 BeanB。构造 BeanB 时，BeanB 又需要 BeanC 作为构造器参数，Spring 容器又不得不先去构造 BeanC。最后构造 BeanC 时，BeanC 又依赖 BeanA 才能完成构造。此时，BeanA 还没构造完成，BeanA 要等 BeanB 实例化好才能完成构造，BeanB 又要等 BeanC，BeanC 等 BeanA。这样就形成了死循环，所以对于以构造器注入方式的循环依赖是无解的，Spring 容器会直接报异常

2. setter注入

   1. 

## IOC

## AOP

## MVC

**SpringMVC**有三大组件：**HandlerMapping处理映射器、HandlerAdapter处理适配器、ViewResolver视图解析器**

![image-20210408132352321](https://i.loli.net/2021/04/08/I3jYTQyeZvS9w85.png)



1. 用户请求发送到**dispatcherservlet**

2. **dispatcherservlet**收到请求之后，调用**handlerMapping**处理器映射

   ![image-20210408135040088](https://i.loli.net/2021/04/08/DYqjfrSUkBTxvsL.png)

3. **handerMapping**根据**url**找到具体的处理器（**handler**），将生成处理器对象以及处理器拦截一并返回给**dispatcherservlet**（handlerexecutionChain）

   ![image-20210408135110299](https://i.loli.net/2021/04/08/qnXSzRtPrf8KcAM.png)

4. **dispatcherservlet**通过**handlerAdapter**调用处理器

5. **handlerAdapter**经过适配调用具体的处理器（**controller**）

   ![image-20210408134755014](https://i.loli.net/2021/04/08/oIM7nb6XOkpurJD.png)

6. **Controller**执行完成返回**ModelAndView**

   ![image-20210408135557307](https://i.loli.net/2021/04/08/ZlLGowzhD5VYnI3.png)

7. **handlerAdapter**将**handler**执行结果**ModelAndView**返回给**DispatcherSevlet**

8. **DispatcherServlet** 将 **ModelAndView** 传给 **ViewReslover** 视图解析器。

   ![image-20210408135807462](https://i.loli.net/2021/04/08/nBzP9aWjFuiRt87.png)

9. **ViewReslover** 解析后返回具体 **View** 对象。

   ![image-20210408135841580](https://i.loli.net/2021/04/08/oibLhMYzAjRKPwq.png)

   

10. **DispatcherServlet** 对 **View** 进行渲染视图（即将模型数据填充至视图中）。

11. **DispatcherServlet** 响应用户。

## 事物传播行为、级别