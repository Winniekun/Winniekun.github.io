# 动态规划

​	**动态规划**(Dynamic Programming，DP)是运筹学的一个分支，将一类活动分为若干个互相联系的阶段，每一个阶段的决策常常影响到下一个阶段的决策，动态规划利用各阶段之间的关系进行逐个求解，最终地到全局最优化的过程，常用于背包问题、生产经营问题。资金管理问题、资源分配问题、最短路径和复杂系统可靠性等有重叠子问题和最优子结构性质的问题中。

### 动态规划套路解析

​	寻找三个重要概念：最优子结构、边界、状态转移公式

​	遵循的一般流程：递归的暴力解法->带备忘录的递归解法->非递归的动态规划解法

### 例题一：LeetCode：70.爬楼梯

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

 https://leetcode-cn.com/problems/climbing-stairs/description/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china

##### 题目解析

​	假设只差最后一步就走到第10（假设n为10）阶台阶时有两种情况：

​	第一种是从9阶走到10 阶；

​	第二种是从8阶走到10阶。

​	如果我们已经知道从0到8阶的走法F(8)=X，从0到9阶的走法F(9)=Y。而10级台阶的走法可以根据最后一步的不同分为如上两种，则F(10)=X+Y=F(9)+F(8)，利用刚才的思路可以推断出F(9)=F(8)+F(7)，F(8)=F(7)+F(6)。并且边界是当只有1阶或者2阶台阶时的走法，显然F(1)=1，F(2)=2,由此我们可以归纳出如下公式：

​	F(1) = 1;

​	F(2) = 2;

​	F(n) = F(n-1)+F(n-2)（n>=3）

###### 方法一：递归求解

```java
public int climbStairs(int n){
	if(n<1)
		return 0;
	if(n == 1)
		return 1;
	if(n == 2)
		return 2;
	return climbStairs(n-1)+climbStairs(n-2);
}
```

该方法的递归路径可以总结为以下的二叉树，二叉树放的节点就是需要计算的次数，时间复杂度

![](C:\Users\Administrator\Desktop\1.png)

###### 方法二：带备忘录的递归解法。

可以清晰的发现树节点中有很多值被重复计算，因此我们可以创建一个哈希表，每次把不同参数的计算结果存入哈希，当遇到相同参数时，再从哈希表中取出。

```java
public int getClimbStairs(int n,HashMap<Integer,Integer> map){
	if(n<1)
		return 0;
	if(n == 1)
		return 1;
	if(n == 2)
		return 2;
	if(map.containsKey(n))
		return map.get(n);
	else{
		map.put(n,getClimbStairs(n-1,map)+getClimbStairs(n-2,map));
		return getClimbStairs(n-1,map)+getClimbStairs(n-2,map);
	}
	
}
```

该方法一共有n个不同的输入，在哈希表中存入了n-2个键值，所以时间复杂度和空间复杂度均为O(n).

###### 方法三：非递归的动态规划解法

根据备忘录算法可以得到一张表如图所示：

| 台阶数 | 1    | 2    | 3    | 4    | 5    | 6    | ……   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 走法数 | 1    | 2    | 3    | 5    | 8    | 13   |      |

我们知道F(n) = F(n-1)+F(n-2)（n>=3），只依赖于它的前两个状态。所以当我们自底向上时只需要保存前两个状态就可以推导出新的状态，而不需要保存所有的子状态。程序从 i=3 开始迭代，一直到 i=n 结束。每一次迭代，都会计算出多一级台阶的走法数量。迭代过程中只需保留两个临时变量a和b，分别代表了上一次和上上次迭代的结果。 为了便于理解，引入了temp变量。temp代表了当前迭代的结果值。时间复杂度为O(n)，空间复杂度为O(1).

```java
public int climbStairs(int n) {
        if(n==1)
            return 1;
        if(n==2)
            return 2;
        int a = 1;
        int b = 2;
        int temp = 0;
        for(int i=3;i<=n;i++){
            temp = a+b;
            a = b;
            b = temp;
        }
        return temp;
    }
```

这就是动态规划，利用简洁的自底向上的递推方法，实现时间和空间的最优化。

### 例题二：国王和金矿(0-1背包问题)

​	有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？

![12](C:\Users\Administrator\Desktop\12.png)

##### 解题步骤

###### 第一步：寻找最优子结构

​	类似爬楼梯问题，第五个金矿存在挖与不挖两种情况。

​		第一种情况：挖第五座金矿，剩余工人数为：10-第五座金矿所需工人数

​		第二种情况：不挖第五座金矿，剩余工人为：10人

​	根据需要的参数，我们把金矿数设为N，工人数设为W，金矿的黄金量设为G[]，所需工人数为P[]，

则最优选择F（5,10）=  Max（   F(4,10)，F(4,10-P[4]) + G[4]  ）

###### 第二步：边界条件

​	当只有一个金矿时，剩余工人数  >  所需工人数 ，挖当前金矿，得到黄金数为G[0]，否则不挖，得到黄金数为0；即：

​	当N=1时，W>=P[0]，F(N,W) = G[0];

​	当N=1时，W<P[0]，F(N,W) = 0;

###### 第三步：状态转移公式

​	F(N，W) = 0  （N <=1,W<P[0]）;

​	F(N，W) = G[0]  （N ==1,W>=P[0]）;

​	F(N，W) = F(N-1，W) （N >1,W<P[N-1]）;  //即总人数<第N座金矿所需人数

​	F(N，W) = Max(F(N-1，W)，F(N-1,W - P[N-1])+G[N-1]) （N >1,W>P[N-1]）;

##### 实现方法

###### 	方法一：递归求解

把状态转移方程式翻译成递归程序，递归的结束的条件就是方程式当中的边界。因为每个状态有两个最优子结构，所以递归的执行流程类似于一颗高度为N的二叉树。方法的时间复杂度是O(2^N)

```java
/**
     *
     * @param G 金矿储存量
     * @param N 金矿数
     * @param W 工人数
     * @param P 需要的挖矿人数
     * @return
     */
    public int getKingGold(int G[],int N,int W,int P[])throws Exception{
        if (N>G.length)throw new Exception("金矿数不匹配！");
        if(N<=1 && W < P[0]) return 0;            //当数量人数少于 需要挖矿的人数时
        if (N==1 && W >= P[0]) return G[0];         //最后一个矿时 人数多于需要挖矿的人数
        if (N>1 &&  W < P[N-1])return getKingGold(G,N-1,W,P);
        int num1 = getKingGold(G,N-1,W,P);
        int num2 = getKingGold(G,N-1,W-P[N-1],P) + G[N-1];
        return Math.max(num1,num2);
    }

```



###### 	方法二：带备忘录的递归求解

在简单递归的基础上增加一个HashMap备忘录，用来存储中间结果。HashMap的Key是一个包含金矿数N和工人数W的对象，Value是最优选择获得的黄金数。方法的时间复杂度和空间复杂度相同，都等同于备忘录中不同Key的数量。

```java
public int getKingGoldwithMap(int G[],int N,int W,int P[],Map<Integer,Integer> map)throws Exception{
        if (N>G.length)throw new Exception("金矿数不匹配！");
        if(N<=1 &&  W < P[0]) return 0;            //当数量人数少于 需要挖矿的人数时
        if (N==1 && W >= P[0]) return G[0];         //最后一个矿时 人数多于需要挖矿的人数
        if (N>1 &&  W < P[N-1])return getKingGold(G,N-1,W,P); 
        DicText obj = new DicText(N,W);
        if (map.containsKey(obj.hashCode())){
            return map.get(obj.hashCode());
        }else{
            int num1 = getKingGold(G,N-1,W,P);
            int num2 = getKingGold(G,N-1,W-P[N-1],P) + G[N-1];
            int result  = Math.max(num1,num2);
           	map.put(obj.hashCode(),result);
           	return result;
        }

    }

    private static class DicText{
        private int n;
        private int w;

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            DicText dicText = (DicText) o;
            return n == dicText.n &&
                    w == dicText.w;
        }

        @Override
        public int hashCode() {
            final  int seed = 31;
            int num = seed * n +2 ;
            num = num * w + 1;
            return num;
        }

        public DicText(int n, int w) {
            this.n = n;
            this.w = w;
        }

        public int getN() {
            return n;
        }

        public void setN(int n) {
            this.n = n;
        }

        public int getW() {
            return w;
        }

        public void setW(int w) {
            this.w = w;
        }
    };
```

这里将金矿剩余数和人数的剩余数加在一起做成一个类，并将hashcode值进行重写。

###### 	方法三：非递归的动态规划求解

```java
public int getMostGold(int n,int w,int []g,int[] p){
        int perReuslts []=new int[p.length];
        int result [] = new int [p.length];
        //当只有一座金矿时，填充边界格子的值
        for (int i = 0;i<=n ;i++){
            if (i<p[0]){
                perReuslts[i] = 0;
            }else {
                perReuslts[i] = g[0];
            }
        }
        //填充其余格子的值，外层循环是金矿的数量，内层循环是人工数
        for (int i = 0;i<n ;i++){
            for (int j = 0;j<=w;j++){
               if (j<p[i]){
                result[j] = perReuslts[j];
              }else {
                   result[j] = Math.max(perReuslts[j],perReuslts[j-p[i]] + g[i]);
               }
            }
        }
        return result[n];
    }
```

方法利用两层迭代，来逐步推导出最终结果。在外层的每一次迭代，也就是对表格每一行的迭代过程中，都会保留上一行的结果数组 preResults，并循环计算当前行的结果数组results。方法的时间复杂度是 O(n * w)，空间复杂度是(w)。

##### 特殊思考：如果题目变为如图：

总矿工人数为1000人，

![](C:\Users\Administrator\Desktop\3.png)

我们可以发现动态规划的时间和空间复杂度都与W 有关，而简单递归与W无关。如果继续使用动态规划，时间复杂度为O(n*w) = 5000，开辟1000单位的空间。相比简单递归的时间复杂度O(2^n)，只需要计算32次，开辟5单位(递归深度)的空间。动态规划的性能反而不如简单递归。

# 刷题指南

| [474.一和零](https://leetcode-cn.com/problems/ones-and-zeroes/) |      |
| ------------------------------------------------------------ | ---- |
|                                                              |      |
|                                                              |      |
|                                                              |      |
|                                                              |      |
|                                                              |      |
|                                                              |      |
|                                                              |      |
|                                                              |      |
|                                                              |      |

