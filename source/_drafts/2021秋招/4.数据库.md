# Mysql

## 0.讲讲数据库的三大范式

### 1NF

**1NF 指的是数据库表中的任何属性都是原子性的，不可再分**。这很好理解，我们在设计某个字段的时候，对于字段 X 来说，就不能把字段 X 拆分成字段 X-1 和字段 X-2。事实上，任何的 DBMS 都会满足第一范式的要求，不会将字段进行拆分。

### 2NF

**2NF 指的数据表里的非主属性都要和这个数据表的候选键有完全依赖关系**。==所谓完全依赖不同于部分依赖，也就是不能仅依赖候选键的一部分属性，而必须依赖其全部属性==。

### 3NF

**3NF在满足2NF的基础上, 对任何非主属性都不传递依赖于主属性**, 也就是说不能存在非主属性 A 依赖于非主属性 B，非主属性 B 依赖于候选键的情况。

我们用球员 player 表举例子，这张表包含的属性包括球员编号、姓名、球队名称和球队主教练。现在，我们把属性之间的依赖关系画出来，如下图所示：

![img](data:image/jpeg;base64,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)
你能看到球员编号决定了球队名称，同时球队名称决定了球队主教练，非主属性球队主教练就会传递依赖于球员编号，因此不符合 3NF 的要求。

如果要达到 3NF 的要求，需要把数据表拆成下面这样：

球员表的属性包括球员编号、姓名和球队名称；球队表的属性包括球队名称、球队主教练。

### 总结

1NF 需要保证表中每个属性都保持原子性；2NF 需要保证表中的非主属性与候选键完全依赖（需要主键唯一标识一行记录）；3NF 需要保证表中的非主属性与候选键不存在传递依赖。



## **1. 能说下myisam 和 innodb的区别吗？**

myisam引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，所以一般用于有大量查询少量插入的场景来使用，而且myisam不支持外键，并且索引和数据是分开存储的。

innodb是基于聚簇索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。



## **2. 说下mysql的索引有哪些吧，聚簇和非聚簇索引又是什么？**

索引按照数据结构来说主要包含B+树和Hash索引。

假设我们有张表，结构如下：

```sql
create table user(
  id int(11) not null,
  age int(11) not null,
  primary key(id),
  key(age)
);
```

B+树是左小右大的顺序存储结构，节点只包含id索引列，而叶子节点包含索引列和数据，这种数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引。假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。

![mysql聚簇索引](https://i.loli.net/2021/03/19/5NwVbDYhXIqHZun.jpg)



这是主键聚簇索引存储的结构，那么非聚簇索引的结构是什么样子呢？非聚簇索引(二级索引)保存的是主键id值，这一点和myisam保存的是数据地址是不同的。



![非聚簇索引](https://i.loli.net/2021/03/19/bXMKTEnWCRz9QmY.jpg)



最终，我们一张图看看InnoDB和Myisam聚簇和非聚簇索引的区别



![聚簇-非聚簇索引](https://i.loli.net/2021/03/19/5VjaCGtmR16kuq7.jpg)





## **3. 那你知道什么是覆盖索引和回表吗？**

==覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。==

而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。

以上面的user表来举例，我们再增加一个name字段，然后做一些查询试试。

```sql
explain select * from user where age=1; //查询的name无法从索引数据获取
explain select id,age from user where age=1; //可以直接从索引获取
```

## 4. 联合索引了解吗

对表上多个列进行索引。

譬如建立了多个一个(a,b)索引

1. where a = xxx and b = yyy 可以走索引
2. where a = xxx 可以走索引
3. where b = yyy 不能走该索引

联合索引对第二个键值进行了排序处理。这样方便一些场景的使用

1. 查询用户购物情况，根据user_id（主键）查找出用户的消费记录，然后再根据buy_date进行排序，取出最近三次的消费。
   1. 使用联合索引就可以避免多一次的排序操作。



```sql
explain 中 Extra 中标识 using index -- 表示进行覆盖索引操作
```



## **5. 锁的类型有哪些呢**

mysql锁分为**共享锁**和**排他锁**，也叫做读锁和写锁。

读锁是共享的，可以通过lock in share mode实现，这时候只能读不能写。

写锁是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为**表锁**和**行锁**两种。

表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。

行锁又可以分为**乐观锁**和**悲观锁**，悲观锁可以通过for update实现，乐观锁则通过版本号实现。



## **6. 你能说下事务的基本特性和隔离级别吗？**

### 什么是事物：

事物是数据库的一大特性。事物会将数据库从==一种一致性态转移到另一种一致状态==。可以有一条简单的sql构成，也可以由一组复杂的sql组成，==同时事物也是是访问并修改数据库中数据的基本单位==。在事物中，所有命令要么全部执行成功，要么就全部都不执行。这时事物的目的。事物有四大特性：原子性（Atomicity）、一致性（consisstency）、隔离型（isolation）、持久性（durability）。

#### **原子性**:

 原子性表示，整个数据库事物是==不可分割的工作单位==，只有使事物事物中所有的数据库操作都执行，才算是整个事物成功。事物中任何一条sql执行失败，已经执行成功的sql语句也必须要撤销。

#### **一致性:**

 一致性表示将数据库中的数据从一个状态转移到下一种一致性状态。在执行前后==数据库的完整性约束没有被破坏==

>  表中的名字字段为唯一约束，若是在事物执行之后，表中的名字变得不唯一了，也就表明了事物将数据库从一种状态变为了一种不一致的状态。

#### **隔离性:** 

隔离性表示，==一个事物内的操作，对于其他的事物是不可见的==。

隔离型主要规定了各个事物之间相互影响的程度。

- 要求每个读写事物的对象对其他事物的操作对象能相互分离，也就是该事物提交前对其他事物都不可见，通常通过锁来实现。
- 设立了不同程度的隔离级别，通过适度的破坏一致性，得以提高性能

#### **持久性：**

指的是一旦事务提交，所做的修改就会永久保存到数据库中。

### 隔离级别：

根据对事物的四大特性的介绍可以得出，隔离性和一致性是有一定的冲突的，有时候为了提高性能，会适度的破坏一致性。 譬如当前的事物对数据做的修改还没有提交，但是另一个事物已经能够看到对这条数据的修改。也就是所谓的**脏读**，其只能在**读未提交**的隔离级别下发生。

#### 事物并发存在的问题

1. **脏读**	

   1. 假设银行中A，B的存款分别为10000，此时有两个事物1、2。1用于操作A向B转账500元。2用于操作统计A和B的总金额

      ![image-20210305212113218](https://i.loli.net/2021/03/05/QKowXd3YpJcbSUI.png)

      我们不考虑任何加锁机制，仅仅从程序运行的角度来看，事务 1 执行成功之后，A 成功转了 100 元到 B 账户，这时 A 余额还剩 9500 元，B 余额剩 10500，总和为 2000；但是事务 2 的统计求和算出来的结果却是 A + B = 19500。这种现象通俗来讲就是：**还没有提交的事物被其他事物读取到了**。我们称之为**脏读**

2. **不可重复读**

   ![image-20210305212559979](https://i.loli.net/2021/03/05/CnuObQk7eAz93Md.png)

   同样的道理，还是上述的例子，事物1在事物2查询A的余额之后更新了A的余额，然后事物B重新读取A的余额，然后就会发现在事物2期间，前后两次读取的结果不同。通俗来讲就是：==在用一个事物中，同样的记录读取两遍，但是结果却不一致。==

3. **幻读**

   幻读的命名有些魔幻。

   ![image-20210305213137969](https://i.loli.net/2021/04/09/SdlIgHjmOuoDbxr.png)

   对于幻读的解释：同一个事物中，同样的条件，第一次和第二次读出来结果的记录数量不同。就像是平时出现的了幻象，明明刚开始看到的是这样的，但是再细看，诶！少了个东西，闹鬼了。

   **幻读和不可重复读区别**

   1. 简单来理解：
      1. 不可重复读是在某个 事物中，对**同一条**结果每次的读取结果不同。
      2. 幻读是指在某个事物中，前后两次读取同一个**范围**返回数量不同。

   这么理解也仅仅是便于理解，实际不准确。可能存在另一个事务先插入一条记录然后再删除一条记录的情况，这个时候两次查询得到的记录数也是一样的，但这也是幻读，所以严格点的说法应该是：**两次读取得到的结果集不一样**

   不怎么理解，但是总结之后不难感觉到：

   	1. 不可重复读是因为其他事物执行了update操作。
   	2. 幻读是因为其他事物执行了insert或delete操作。

   ![image-20210305214207658](https://i.loli.net/2021/03/05/SyqYezbpXZoBUQn.png)

4. **丢失更新**

   1. 第一类丢失更新（回滚覆盖）

      ![image-20210305225045045](https://i.loli.net/2021/03/05/lmGZbnotdspYO5D.png)

   2. 第二类丢失更新（提交覆盖）

      1. 假设两个事务同时对 A 的余额进行修改，他们都查出 A 的当前余额为 1000，然后事务 2 修改 A 的余额，将 A 的余额加 100 变成 1100 并提交，这个时候 A 的余额应该是 1100，但是这个时候事务 1 并不知道 A 的余额已经变动，而是继续在 1000 的基础上进行减 100 的操作并提交事务，就这样事务 2 的提交被覆盖掉了，事务 1 提交之后 A 的余额变成了 900 元。这就是说事务 1 的提交覆盖了事务 2 的提交，事务 2 的 UPDATE 操作完全丢失了，整个过程如下图所示

         ![image-20210305225113327](https://i.loli.net/2021/03/05/rdaHYBDclQnx7iv.png)


#### 隔离级别

上述那么多的并发情况下事物可能出现的问题，该如何解决嘞。最简单的方法就等同于我们写一个线程安全的方法一个道理：**加锁**

1. 写的时候不允许其他事务读，读的时候不允许其他事务写，这样是不是就完美解决了？确实如此。这其实就是四大隔离级别里的 **序列化**，在序列化隔离级别下，可以保证事务的安全执行，数据库的一致性得以保障，但是它大大降低了事务的并发能力，性能最低。

==为了调和事务的安全性和性能之间的冲突，适当的降低隔离级别，可以有效的提高数据库的并发性能。于是便有了四种不同的隔离级别：==

- 读未提交（Read Uncommitted）：可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到；
- 读已提交（Read Committed）：事务中只能看到已提交的修改，不会出现脏读现象，但是会出现幻读，不可重复读；（大多数数据库的默认隔离级别都是 RC，但是 MySQL InnoDb 默认是 RR）
- 可重复读（Repeatable Read）：MySQL InnoDb 默认的隔离级别，解决了不可重复读问题，但是任然存在幻读问题；（MySQL 的实现有差异，后面介绍）
- 序列化（Serializable）：最高隔离级别，啥并发问题都没有。

#### 传统的隔离级别

上面说了很多，其实我一直在刻意的避免谈到锁，因为隔离级别和锁本身就是两个东西，SQL 规范中定义的四种隔离级别，分别是为了解决事务并发时可能遇到的四种问题，至于如何解决，实现方式是什么，规范中并没有严格定义。锁作为最简单最显而易见的实现方式，可能被广为人知，所以大家在讨论某个隔离级别的时候，往往会说这个隔离级别的加锁方式是什么样的。其实，锁只是实现隔离级别的几种方式之一，除了锁，实现并发问题的方式还有[时间戳](https://en.wikipedia.org/wiki/Timestamp-based_concurrency_control)，[多版本控制](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)等等，这些也可以称为[无锁的并发控制](https://en.wikipedia.org/wiki/Non-lock_concurrency_control)。

传统的隔离级别是基于锁实现的，这种方式叫做 **基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC）**。通过对读写操作加不同的锁，以及对释放锁的时机进行不同的控制，就可以实现四种隔离级别。传统的锁有两种：读操作通常加共享锁（Share locks，S锁，又叫读锁），写操作加排它锁（Exclusive locks，X锁，又叫写锁）；加了共享锁的记录，其他事务也可以读，但不能写；加了排它锁的记录，其他事务既不能读，也不能写。另外，对于锁的粒度，又分为行锁和表锁，行锁只锁某行记录，对其他行的操作不受影响，表锁会锁住整张表，所有对这个表的操作都受影响。

归纳起来，四种隔离级别的加锁策略如下：

- 读未提交（Read Uncommitted）：事务读不阻塞其他事务读和写，事务写阻塞其他事务写但不阻塞读；通过对写操作加 “持续X锁”，对读操作不加锁 实现；
- 读已提交（Read Committed）：事务读不会阻塞其他事务读和写，事务写会阻塞其他事务读和写；通过对写操作加 “持续X锁”，对读操作加 “临时S锁” 实现；不会出现脏读；
- 可重复读（Repeatable Read）：事务读会阻塞其他事务事务写但不阻塞读，事务写会阻塞其他事务读和写；通过对写操作加 “持续X锁”，对读操作加 “持续S锁” 实现；
- 序列化（Serializable）：为了解决幻读问题，行级锁做不到，需使用表级锁。

结合上面介绍的每种隔离级别分别是用来解决事务并发中的什么问题，再来看看它的加锁策略其实都挺有意思的。其中 **读未提交** 网上有很多人认为不需要加任何锁，这其实是错误的，我们上面讲过，有一种并发问题在任何隔离级别下都不允许存在，那就是第一类丢失更新（回滚覆盖），如果不对写操作加 X 锁，当两个事务同时去写某条记录时，可能会出现丢失更新问题，[这里](http://www.jianshu.com/p/71a79d838443) 有一个例子可以看到写操作不加 X 锁发生了回滚覆盖。再看 **读已提交**，它是为了解决脏读问题，只能读取已提交的记录，要怎么做才可以保证事务中的读操作读到的记录都是已提交的呢？很简单，对读操作加上 S 锁，这样如果其他事务有正在写的操作，必须等待写操作提交之后才能读，因为 S 和 X 互斥，如果在读的过程中其他事务想写，也必须等事务读完之后才可以。这里的 S 锁是一个临时 S 锁，表示事务读完之后立即释放该锁，可以让其他事务继续写，如果事务再读的话，就可能读到不一样的记录，这就是 **不可重复读** 了。为了让事务可以重复读，加在读操作的 S 锁变成了持续 S 锁，也就是直到事务结束时才释放该锁，这可以保证整个事务过程中，其他事务无法进行写操作，所以每次读出来的记录是一样的。最后，**序列化** 隔离级别下单纯的使用行锁已经实现不了，因为行锁不能阻止其他事务的插入操作，这就会导致幻读问题，这种情况下，我们可以把锁加到表上（也可以通过范围锁来实现，但是表锁就相当于把表的整个范围锁住，也算是特殊的范围锁吧）。

从上面的描述可以看出，通过对**锁的类型（读锁还是写锁）**，**锁的粒度（行锁还是表锁）**，**持有锁的时间（临时锁还是持续锁）**合理的进行组合，就可以实现四种不同的隔离级别。

这四种不同的加锁策略实际上又称为 **封锁协议（Locking Protocol）**，所谓协议，就是说不论加锁还是释放锁都得按照特定的规则来。**读未提交** 的加锁策略又称为 **一级封锁协议**，后面的分别是二级，三级，**序列化** 的加锁策略又称为 **四级封锁协议**。

其中三级封锁协议在事务的过程中为写操作加持续 X 锁，为读操作加持续 S 锁，并且在事务结束时才对锁进行释放，像这种加锁和解锁明确的分成两个阶段我们把它称作 **两段锁协议（2-phase locking，简称 2PL）**。在两段锁协议中规定，加锁阶段只允许加锁，不允许解锁；而解锁阶段只允许解锁，不允许加锁。这种方式虽然无法避免死锁，但是两段锁协议可以保证事务的并发调度是串行化的（关于串行化是一个非常重要的概念，尤其是在数据恢复和备份的时候）。在两段锁协议中，还有一种特殊的形式，叫 **一次封锁**，意思是指在事务开始的时候，将事务可能遇到的数据全部一次锁住，再在事务结束时全部一次释放，这种方式可以有效的避免死锁发生。但是这在数据库系统中并不适用，因为事务开始时并不知道这个事务要用到哪些数据，一般在应用程序中使用的比较多。

#### InnoDB隔离级别

其默认的隔离级别是`repeatable read`，和标准的SQL不同的是，InnoDB存储引擎在**可重复读**隔离级别下，使用**next-key lock**锁算法，因此避免幻读的产生。

>  因为“幻读”的这个“读”字在 MySQL 里本身就存在歧义，这个“读”到底指的是快照读，还是当前读？如果是快照读，MySQL 通过版本号来保证同一个事务里每次查询得到的结果集都是一致的；如果是当前读，MySQL 通过 Next-key locks 保证其他事务无法插入新的数据，从而避免幻读问题。当然，如果你的场景里一会是快照读，一会是当前读，导致幻读现象，MySQL 也只能表示自己很无奈了。

虽然数据库的四种隔离级别通过 **LBCC （基于锁的并发控制）**技术都可以实现，但是它最大的问题是它只实现了并发的读读，对于并发的读写还是冲突的，写时不能读，读时不能写，当读写操作都很频繁时，数据库的并发性将大大降低，针对这种场景，MVCC 技术应运而生。MVCC 的全称叫做 **Multi-Version Concurrent Control（多版本并发控制）**，InnoDb 会为每一行记录增加几个隐含的“辅助字段”，（**实际上是 3 个字段：一个隐式的 ID 字段，一个事务 ID，还有一个回滚指针**），==事务在写一条记录时会将其拷贝一份生成这条记录的一个原始拷贝，写操作同样还是会对原记录加锁，但是读操作会读取未加锁的新记录==，这就保证了读写并行。要注意的是，生成的新版本其实就是 **undo log**，它也是实现事务回滚的关键技术。关于 InnoDb 的 MVCC 机制的实现原理推荐看下这篇文章：[MySQL数据库事务各隔离级别加锁情况--read committed && MVCC](http://www.imooc.com/article/17290)。

InnoDb 通过 MVCC 实现了**读写并行**，但是在不同的隔离级别下，读的方式也是有所区别的。首先要特别指出的是，在 **read uncommit** 隔离级别下，每次都是读取最新版本的数据行，所以不能用 MVCC 的多版本，而 serializable 隔离级别每次读取操作都会为记录加上读锁，也和 MVCC 不兼容，所以只有 RC 和 RR 这两个隔离级别才有 MVCC。

![image-20210409200757550](https://i.loli.net/2021/04/09/dNOHgbKDkeUA27R.png)

## **7. 那ACID靠什么保证的呢？**

A原子性由undo log + redo log日志保证，redo log用于记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql，redo log 用于将事物执行成功后的持久化。

C一致性一般由代码层面来保证，

I隔离性由MVCC以及锁来实现

D持久性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复



## **8. 了解过数据库中的那些锁？**

1. **锁类型**就是表锁和行锁两种类型，当然行锁还可以细分成记录锁和间隙锁等更细的类型，锁类型描述的锁的粒度，也可以说是把锁具体加在什么地方

2. **锁模式**描述的是到底加的是什么锁，譬如读锁或写锁。锁模式通常是和锁类型结合使用的

### 表锁&行锁

- 表锁
  - 开销小，加锁块，不会出现死锁；锁的粒度大，但是锁冲突的概率高，并发量低。
- 行锁
  - 开销大，加锁慢，会出现死锁；锁的粒度小，但是锁冲突的概率低，并发量高。

### 行锁

1. 读锁

2. 写锁

常见的**增删改**会自动对操作的数据加写锁。查的时候也可以明确指定锁类型

```sql
select ... lock in share mode; -- 读锁
select ... for update -- 写锁
```

虽然行锁这个名字听起来是这个锁加在某个数据行上，实际为： 在MySQL中，**行锁是加在索引上的**

#### 行锁种类

根据锁的粒度可以把锁细分为表锁和行锁，行锁根据场景的不同又可以进一步细分，在 MySQL 的源码里，定义了四种类型的行锁，如下：

* LOCK_ORDINARY： 也称为Next-Key Lock
  * 锁一条记录及其之间的间隙
* LOCK_GAP: 间隙锁，
  * 锁两个记录之间的GAP，防止记录插入
* LOCK_REC_NOT_GAP：记录锁
  * 只锁记录
* LOCK_INSERT_INTENSION：插入意向GAP锁，
  * 插入记录时使用，是LOCK_GAP的一种特例

## 9. 一些锁的详细阐述

刚开始学习数据库锁的的时候，理解的行锁就是将锁锁在一个行上，然后这一行的记录不能被其他人修改。这种理解其实是很肤浅的。因为行锁还可以锁在行与行之间的间隙上。

### 记录锁

刚才的肤浅的理解就是记录锁的定义

```sql
mysql> udpate accouts set level = 100 where id = 5;
```

这条 SQL 语句就会在 id = 5 这条记录上加上记录锁，防止其他事务对 id = 5 这条记录进行修改或删除。记录锁永远都是加在索引上的，就算一个表没有建索引，数据库也会隐式的创建一个索引。如果 WHERE 条件中指定的列是个二级索引，那么记录锁不仅会加在这个二级索引上，还会加在这个二级索引所对应的聚簇索引上

> 如果 SQL 语句无法使用索引时会走主索引实现全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁。如果一个 WHERE 条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由 MySQL Server 层进行过滤。不过在实际使用过程中，MySQL 做了一些改进，在 MySQL Server 层进行过滤的时候，如果发现不满足，会调用 unlock_row 方法，把不满足条件的记录释放锁（显然这违背了二段锁协议）。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见在没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，而且极大的降低了数据库的并发性能，所以说，更新操作一定要记得走索引。

### 间隙锁

在MySQL中通过**间隙锁**是的在可重复读的隔离级别下，避免了幻读的现象。

**概念**：间隙锁是加在两个索引之间的锁，或者是第一个索引之前，或者最后一个索引之后的间隙。也称为**范围锁**这个范围可以跨一个索引记录，多个索引记录，甚至是空的。

**目的**：使用间隙锁可以防止其他事物在这个范围内插入或修改记录。从而保证两次读取这个范围内的记录不会变，进而解决幻读现象。

因为不像记录锁，仅仅只锁一行，其肯能锁多个，所以会增加数据库的开销。虽然解决了幻读问题，但是数据库的并发型一样受到了影响。所以在选择数据库的隔离级别的时候，需要注意权衡性能和并发性。根据实际情况考虑是否需要使用间隙锁。

```sql
mysql> udpate accouts set level = 100 where id = 5;
```

回到这个例子，这个 SQL 语句在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id = 5 前后两个索引之间加上间隙锁。

值得注意的是，间隙锁和间隙锁之间是互不冲突的，间隙锁唯一的作用就是为了防止其他事务的插入，所以加间隙 S 锁和加间隙 X 锁没有任何区别。

### Next-Key Locks

是**记录锁**+**间隙锁**的组合。

假设一个索引包含10、11、13、20这几个值，可能的Next-key锁如下：

- $(-\infty, 10]$
- $(10, 11]$
- $(11, 13]$
- $(13, 20]$
- $(20, +\infty）$

左闭右开的模式，最后一个是间隙锁。同理，在RC模式下是没有`Next-Key`锁的，只有RR隔离级别才有。

```sql
mysql> udpate accouts set level = 100 where id = 5;
```

如果 id 不是主键，而是二级索引，**且不是唯一索引**，那么这个 SQL 在 RR 隔离级别下会加什么锁呢？答案就是 Next-key 锁，如下：

* $(a, 5]$
* $(5, b)$

其中a,b是id=5的前后两个索引。假设a=1，b=10。那么此时如果插入一条 id = 3 的记录将会阻塞住。之所以要把 id = 5 前后的间隙都锁住，仍然是为了解决幻读问题，因为 id 是非唯一索引，所以 id = 5 可能会有多条记录，为了防止再插入一条 id = 5 的记录，必须将下面标记 ^ 的位置都锁住，因为这些位置都可能再插入一条 id = 5 的记录：

1 ^ 5 ^ 5 ^ 5 ^ 10 11 13 15

可以看出来，Next-key 锁确实可以避免幻读，但是带来的副作用是连插入 id = 3 这样的记录也被阻塞了，这根本就不会引起幻读问题的。

### 插入意向锁

[**插入意向锁**](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-insert-intention-locks) 是一种特殊的间隙锁（所以有的地方把它简写成 II GAP），这个锁表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混淆了。插入意向锁和插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。譬如在上面的例子中，id = 1 和 id = 5 之间如果有两个事务要同时分别插入 id = 2 和 id = 3 是没问题的，虽然两个事务都会在 id = 1 和 id = 5 之间加上插入意向锁，但是不会冲突。

插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，那么间隙锁是如何防止幻读的呢？正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。



## **10. 你们数据量级多大？分库分表怎么做的？**

首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。

**垂直分库**

基于现在微服务拆分来说，都是已经做到了垂直分库了



![分库分表](https://i.loli.net/2021/03/19/k2rTBn3jsL4lgRG.jpg)



**垂直分表**

如果表字段比较多，将不常用的、数据较大的等等做拆分



![垂直分表](https://i.loli.net/2021/03/19/hWTap5XZ1Ky8oVR.jpg)



**水平分表**

首先根据业务场景来决定使用什么字段作为分表字段(sharding_key)，比如我们现在日订单1000万，我们大部分的场景来源于C端，我们可以用user_id作为sharding_key，数据查询支持到最近3个月的订单，超过3个月的做归档处理，那么3个月的数据量就是9亿，可以分1024张表，那么每张表的数据大概就在100万左右。

比如用户id为100，那我们都经过hash(100)，然后对1024取模，就可以落到对应的表上了。



## **11. 那分表后的ID怎么保证唯一性的呢？**

因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：

1. 设定步长，比如1-1024张表我们设定1024的基础步长，这样主键落到不同的表就不会冲突了。
2. 分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种
3. 分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。



## **12. 分表后非sharding_key的查询怎么处理呢？**

1. 可以做一个mapping表，比如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查询到用户列表，再通过user_id去查询。
2. 打宽表，一般而言，商户端对数据实时性要求并不是很高，比如查询订单列表，可以把订单表同步到离线（实时）数仓，再基于数仓去做成一张宽表，再基于其他如es提供查询服务。
3. 数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方式来做。或者异步的形式也是可以的。

```java
List<Callable<List<User>>> taskList = Lists.newArrayList();
for (int shardingIndex = 0; shardingIndex < 1024; shardingIndex++) {
    taskList.add(() -> (userMapper.getProcessingAccountList(shardingIndex)));
}
List<ThirdAccountInfo> list = null;
try {
    list = taskExecutor.executeTask(taskList);
} catch (Exception e) {
    //do something
}

public class TaskExecutor {
    public <T> List<T> executeTask(Collection<? extends Callable<T>> tasks) throws Exception {
        List<T> result = Lists.newArrayList();
        List<Future<T>> futures = ExecutorUtil.invokeAll(tasks);
        for (Future<T> future : futures) {
            result.add(future.get());
        }
        return result;
    }
}
```



## **13. 说说mysql主从同步怎么做的吧？**

**搭建过程**

1. [基础文章](https://blog.csdn.net/u013068184/article/details/107691389)
   1. 需要添加mysqlId
2. [第二篇文章](https://blog.csdn.net/zyhlwzy/article/details/80569422)
3. [第三片文章](https://zhuanlan.zhihu.com/p/115011360)

首先先了解mysql主从同步的原理

![image-20210408235211049](https://i.loli.net/2021/04/08/hfbz6PvQUi85Erg.png)

1. master提交完事务后，写入binlog
2. slave连接到master，获取binlog
3. master创建dump线程，推送binglog到slave
4. slave启动一个IO线程读取同步过来的master的binlog，记录到relay log（中继日志）中
5. slave再开启一个sql线程读取relay log事件并在slave执行，完成同步
6. slave记录自己的binglog
   1. 是否记录看需求

![mysql-主从同步](https://i.loli.net/2021/03/19/wHfOo2pNazKVivQ.jpg)





由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。

**全同步复制**

主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

**半同步复制**

和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。

#### 主从复制的应用场景

1. 从服务器作为主服务器的实时数据备份

2. 主从服务器实时读写分离，从服务器实现负载均衡

   1. 通过程序或者代理软件实现对客户端请求的读写分离
      1. 让从服务器仅处理用户的select查询请求，降低用户查询响应时间及读写同时在主服务器带来的访问压力
      2. 更新数据的查询仍然交给主服务器，确保主服务器和从服务器保持实时同步

3. 把多个从服务器根据业务重要性进行拆分访问

   * 把几个不同的从服务器，根据公司的业务进行拆分。
     - 有外部用户提供查询服务的从服务器
     - 有内部DBA用来数据备份的从服务器
     - 又供公司内部人员提供访问的后台、脚本、日志分析及供开发人员查询的从服务

   进而降低主服务器的压力，还可以做到数据库对外部用户浏览、内部用户业务处理、DBA人员备份等互不印象。



## **14. 那主从的延迟怎么解决呢？**

1. 针对特定的业务场景，读写请求都强制走主库
2. 读请求走从库，如果没有数据，去主库做二次查询



## 15. SQL注入的理解

SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，在一些对SERVER端发起的请求参数中植入一些SQL代码，SERVER端在执行SQL操作时，会拼接对应参数，同时也将一些SQL注入攻击的“SQL”拼接起来，导致会执行一些预期之外的操作。

```sql
SELECT * FROM user WHERE username = 'ls' AND password = '123456'
```

其中，sql会将#及--以后的字符串当作注视处理，如果我们用` or 1 = 1#`作为用户名参数，那么最后执行的SQL语句如下：

```sql
select * from user where username='' or 1=1 #' and password='123456'
```

而#会忽略后面的语句，而1=1属于常等型条件，因此这个SQL将查询出所有的登录用户。其实上面的SQL注入只是在参数层面做了些手脚，如果是引入了一些功能性的SQL那就更危险了，比如上面的登录功能，如果用户名使用这个 `' or 1=1;delete * from users; #`，那么在";"之后相当于是另外一条新的SQL，这个SQL是删除全表，是非常危险的操作，因此SQL注入这种还是需要特别注意的。

**如何解决：**

1. 严格的参数校验

2. SQL预编译

   具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到MySQL服务器，MySQL服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。我们常用的JDBC就有预编译功能，不仅提升性能，而且防止SQL注入。

# Redis

## Redis常用数据类型

### 字符串

对应的数据结构就是==字符串==

### 列表

支持存储一组数据，有两种实现方法：

1. 压缩列表
2. 双向循环链表

列表中的存储数量比较小的时候，列表可以采用压缩列表的实现方式

1. 列表中保存的单个数据（有可能是字符串类型的）小于 64 字节
2. 列表中数据个数少于 512 个

#### **压缩列表：**

> 和数组类似的数据结构，不过压缩列表允许存储的大小不同。
>
> ![image](https://static001.geekbang.org/resource/image/49/b5/49fd8d46eb94f463ace98717f11c2cb5.jpg)
>
> 压缩列表这种存储结构，一方面==比较节省内存==，另一方面可以==支持不同类型数据的存储==。而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高，==	不过无法支持随机读取了==

#### **双向循环链表：**

> Redis 的这种双向链表的实现方式，非常值得借鉴。它额外定义一个 list 结构体，来组织链表的首、尾指针，还有长度等信息。这样，在使用的时候就会非常方便。
>
> ```c
> // 以下是C语言代码，因为Redis是用C语言实现的。
> typedef struct listnode {
> struct listNode *prev;
> struct listNode *next;
> void *value;
> } listNode;
> 
> 
> typedef struct list {
> listNode *head;
> listNode *tail;
> unsigned long len;
> // ....省略其他定义
> } list;
> ```
>
> 

### 集合

集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，**一种是基于有序数组，另一种是基于散列表**。当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型。

1. 存储的数据都是整数
2. 存储的数据元素个数不超过 512 个

当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。

### 有序集合

实际上，跟 Redis 的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。**当数据量比较小的时候，Redis 会用压缩列表来实现有序集合**。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：

1. 所有数据的大小都要小于 64 字节
2. 元素个数要小于 128 个

### 字典

一种是我们刚刚讲到的**压缩列表**，另一种是**散列表**，散列表的实现支持扩容和缩容。同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：

1. 字典中保存的键和值的大小都要小于 64 字节
2. 字典中键值对的个数要小于 512 个

> 当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。Redis 使用==MurmurHash2==这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，==Redis 使用链表法来解决==。除此之外，Redis 还支持散列表的==动态扩容、缩容==。

**当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右（具体值需要计算才能得到，如果感兴趣，你可以去阅读源码）。当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小（这个值也是计算得到的，如果感兴趣，你也可以去阅读源码）。**

### 总结

| 数据类型\数据结构 | 压缩列表                                                     | 有序数组                                                     | 哈希表             | 字符串             | 双向循环链表       | 跳表               |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------ | ------------------ | ------------------ | ------------------ |
| **字符串**        |                                                              |                                                              |                    | :white_check_mark: |                    |                    |
| **列表**          | :white_check_mark:1. 列表中保存的单个数据（有可能是字符串类型的）小于 64 字节， 2. 存储的数据元素个数不超过 512 个 |                                                              |                    |                    | :white_check_mark: |                    |
| **字典**          | :white_check_mark: 1. 字典中保存的键和值的大小都要小于 64 字节 2.字典中键值对的个数要小于 512 个 |                                                              | :white_check_mark: |                    |                    |                    |
| **集合**          |                                                              | :white_check_mark: 1. 所有数据的大小都要小于 64 字节 2. 元素个数要小于128个 | :white_check_mark: |                    |                    |                    |
| **有序集合**      | :white_check_mark: 1. 所有数据的大小都要小于 64 字节 2.元素个数要小于 128 个 |                                                              |                    |                    |                    | :white_check_mark: |

![image-20210414222607157](https://i.loli.net/2021/04/14/L9yzJF8GHnpUM1m.png)

## **Redis为什么快呢？**

redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：

1. 完全基于内存操作
2. C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高
3. 使用单线程，避免下文的切换带来的成本开销
   1. 单线程主要是指Redis的网络I/O和键值对读写由一个线程来完成，也就是Redis对外提供存储服务的主要流程
   2. 对于其他功能，比如持久化等都是由额外的线程执行的
4. 基于非阻塞的IO多路复用机制



### Redis中I/O多路复用原理

为了处理客户端的一个请求，Redis会做如下的工作

1. 监听客户端的请求（bind/listen）
2. 和客户端建立连接（accept）
3. 从socket中读取请求（recv）
4. 解析请求、根据请求获取结果（get）
5. 返回给客户端，向socket中写回数据（send）

<img src="/Users/weikunkun/Library/Application Support/typora-user-images/image-20210423143252526.png" alt="image-20210423143252526" style="zoom:50%;" />

**存在的阻塞点**

1. accept
   1. Redis监听到一个客户端有连接请求，但一直未能成功建立起连接，会阻塞在accept()
   2. 导致其他客户端无法和redis服务连接
2. recv
   1. 从客户端读取数据，但是数据还未读取完全

<img src="https://i.loli.net/2021/04/23/e3qiDpMdZxQctA4.png" alt="image-20210423145121475" style="zoom:50%;" />



#### 网络编程中的IO模型

[网络IO模型](/Users/weikunkun/Library/Mobile Documents/com~apple~CloudDocs/_posts/2021春招/IO模型.md)



## **那为什么Redis6.0之后又改用多线程呢?**

redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。

这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。



## **知道什么是热key吗？热key问题怎么解决？**

所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。



![redis-热key](https://i.loli.net/2021/03/19/8LxRTCSUfeN34oK.jpg)



针对热key的解决方案：

1. 提前把热key打散到不同的服务器，降低压力
2. 加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询



## **什么是缓存击穿、缓存穿透、缓存雪崩？**

### **缓存击穿**

缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。

解决方案：

1. 加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。
2. 不使用锁进行限制，而是使用类似Semaphore的工具限制并发数，比如限制为10，这样既限制了回源并发数不至于太大，又能使得一定量的线程可以同时回源。

![redis-缓存击穿](https://i.loli.net/2021/03/19/xAlvBzwJCy4TOfG.jpg)



### **缓存穿透**

缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。



![缓存穿透](https://i.loli.net/2021/03/19/BrGn7ComeFwzJTj.jpg)



1. 加一层布隆过滤器。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。

这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。

显然，使用布隆过滤器之后会有一个问题就是误判，因为它本身是一个数组，可能会有多个值落到同一个位置，那么理论上来说只要我们的数组长度够长，误判的概率就会越低，这种问题就根据实际情况来就好了。

![缓存穿透2](https://i.loli.net/2021/03/19/QY14uo8wngSWXsU.jpg)

2. 对不存在的数据，同样设置一个特殊特殊的value到缓存中，比如当数据库中查出的用户信息为空的时候，设置 NODATA 这样具有特殊含义的字符串到缓存中。这样下次请求缓存的时候还是可以命中缓存，即直接从缓存返回结果，不查询数据库。

   ```java
   @GetMapping("right")
   public String right(@RequestParam("id") int id) {
       String key = "user" + id;
       String data = stringRedisTemplate.opsForValue().get(key);
       if (StringUtils.isEmpty(data)) {
           data = getCityFromDb(id);
           //校验从数据库返回的数据是否有效
           if (!StringUtils.isEmpty(data)) {
               stringRedisTemplate.opsForValue().set(key, data, 30, TimeUnit.SECONDS);
           }
           else {
               //如果无效，直接在缓存中设置一个NODATA，这样下次查询时即使是无效用户还是可以命中缓存
               stringRedisTemplate.opsForValue().set(key, "NODATA", 30, TimeUnit.SECONDS);
           }
       }
       return data;
   }
   ```

   



### **缓存雪崩**

当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。



![缓存雪崩](https://i.loli.net/2021/03/19/OJHqT9riIGKXktZ.jpg)



针对雪崩几个解决方案：

1. 针对不同key设置不同的过期时间，避免同时过期
2. 让缓存不主动过期，初始化缓存数据的时候，设置缓存永不过期，然后启动一个后台线程30s一次定时把所有数据更新到缓存。而且通过适当的休眠，控制从数据库更新数据的频率，降低数据库压力。
3. 限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB
4. 二级缓存，同热key的方案。



## 缓存和数据库同步策略

上述提到的雪崩、击穿、穿透都属于数据过期后的被动删除。实际情况下，修改了原数据后，考虑到数据更新的及时性，会采取主动更新缓存的策略

1. 先更新缓存，后更新数据库
2. 先更新数据库，后更新缓存
3. 先删除缓存，再更新数据库，访问的时候按需加载到缓存
4. 先更新数据库，再删除缓存，访问的时候按需加载到缓存

### 先更新缓存、后更新数据库

数据库设计复杂，压力集中，数据库因为超时等原因操作失败的可能性大，此外还会涉及到事物，很可能因为数据库更新失败，导致缓存和数据库的数据不一致。

### 先更新数据库、后更新缓存

1. 如果线程 A 和 B 先后完成数据库更新，但更新缓存时却是 B 和 A 的顺序，那很可能会把旧数据更新到缓存中引起数据不一致
2. 我们不确定缓存中的数据是否会被访问，不一定要把所有数据都更新到缓存中去。

### 先删除缓存、再更新数据库、访问的时候按需加载到缓存

并发情况下，可能删除后，还没更新数据库数据，另一个线程读取了旧值，并放入缓存。

### 先更新数据库、再删除缓存、访问的时候按需加载到缓存

虽然在极端情况下，这种策略也可能出现数据不一致的问题，但概率非常低，基本可以忽略。举一个“极端情况”的例子，比如更新数据的时间节点恰好是缓存失效的瞬间，这时 A 先读取到了旧值，随后在 B 操作数据库完成更新并且删除了缓存之后，A 再把旧值加入缓存。

需要注意的是，更新数据库后删除缓存的操作可能失败，如果失败则考虑把任务加入延迟队列进行延迟重试，确保数据可以删除，缓存可以及时更新。==因为删除操作是幂等的==，所以即使重复删问题也不是太大，这又是删除比更新好的一个原因。

> 在更新数据库和删除缓存期间，其他线程读取的数据是旧值，如何解决？
>
> > 目标是为了避免长期的不一致（读取到了旧值，放入缓存属于长期不一致，因为需要等待新的一个缓存周期。）
> >
> > 但是先更新数据库，后删除缓存，仅仅是临时的不一致。==并且既然已经引入了缓存了，绝对的一致是真的需要吗？？==

### 总结

> 针对缓存更新推荐的方式是：数据库中的数据不由数据库更新操作主动触发，统一在需要的时候按需进行加载。数据更新后，及时删除缓存中的数据即可。

## **Redis的过期策略有哪些？**

redis主要有2种过期删除策略

### **惰性删除**

惰性删除指的是当我们查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。



![reidis惰性删除](https://i.loli.net/2021/03/19/XUBVf19ZGDLlgSH.jpg)



### **定期删除**

定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。



## **那么定期+惰性都没有删除过期的key怎么办？**

假设redis每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存在redis里面无法被删除，这时候就会走到redis的内存淘汰机制。

1. volatile-lru：从已设置过期时间的key中，移除最近最少使用的key进行淘汰
2. volatile-random：从已设置过期时间的key中随机选择key淘汰
3. volatile-ttl：从已设置过期时间的key中，移除将要过期的key
4. allkeys-lru：从key中选择最近最少使用的进行淘汰
5. allkeys-random：从key中随机选择key进行淘汰
6. noeviction：当内存达到阈值的时候，新写入操作报错



## **持久化方式有哪些？有什么区别？**

redis持久化方案分为RDB和AOF两种。

### **RDB**

它的作用是将某个时间点上的==数据库状态保存到RDB文件中==。该文件是一个压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。同时因为RDB文件是保存在磁盘中的，所以及时redis崩溃或者退出，只要RDB文件存在，就可以用来还原数据库状态。

![image-20210409153537633](https://i.loli.net/2021/04/09/U1TwkRmEuIPgZ4F.png)

#### 如何生成、载入RDB文件

##### 手动

1. save

   save命令会阻塞redis服务器进程，直到RDB文件创建完成。在阻塞期间，redis无法处理任何命令请求

   ```shell
   redis> save
   OK
   ```

2. bgsave

   和save命令不同，bgsave会fork出一个子进程，专门用来生成RDB文件，父进程可以继续执行其他的命令请求

   ```shell
   redis> bgsave
   Background saving started
   ```

**核心伪代码**

```python
def SAVE():
  # 创建RDB文件
  rdbSave()
# 整体就是fork的调用，然后根据pid不同执行不同的命令
def BGSAVE():
  # 创建子进程
  pid = fork();
  # 子进程
  if pid == 0:
    # 创建RDB文件
    rdbSave();
    #完成后向父进程发送信号
    signal_parent();
  # 父进程
  else if pid > 0 :
    #父进程执行命令请求，并通过轮询等待子进程的信号
    handle_request_and_wait_signal();
  else :
    # 异常处理
    handle_fork_error();
```

RDB文件的创建有两种方式，但是载入是redis自己自动进行载入，没有单独的用于载入的命令。不过有一个小细节

1. 如果服务器开启了AOF持久化功能，服务器会优先加载AOF文件来还原数据库状态
2. 如果服务器关闭了AOF持久化功能，服务器才会使用RDB文件来还原数据库状态

**其他**

1. 执行save时，redis服务器会阻塞所有的请求命令。不过对bgsave而言，父进程是可以执行命令请求的。不过bgsave和save之间是互斥的，两者不能同时执行（防止父子进程出现竞争）

2. 同时bgsave和bgrewriteaof两者也是不能同时执行的，当一个正在执行，另一个只能等上一个执行结束再开始执行。不能同时执行也是处于性能考虑，并发的执行IO操作总是不太好。
3. redis在载入rdb文件期间，会一直处于阻塞状态，直到加载完成。

##### 自动

redis支持自定义配置，使得服务器能够每隔一段时间执行一次bgsave命令

```shell
save 900 1  900s 内，对数据库操作至少1次修改
save 300 10 300s 内，对数据库操作至少10次修改
save 60 10000 60s 内，对数据库操作至少1000次修改
```



### **AOF**

AOF和RDB不同，AOF是通过保存redis服务器所执行的写命令来记录数据库状态的。

AOF通过==命令追加、文件写入、文件同步==三个步骤来实现持久化机制。

1. 当AOF持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加到**aof_buf缓冲区**的末尾
2. 在服务器每结束一个事件循环之前，将会调用flushAppendOnlyFile函数决定是否要将aof_buf的内容保存到AOF文件中，可以通过配置appendfsync来决定。

```text
always ##aof_buf内容写入并同步到AOF文件
everysec ##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步
no ##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定
```

如果不设置，默认选项将会是everysec，因为always来说虽然最安全（只会丢失一次事件循环的写命令），但是性能较差，而everysec模式只不过会可能丢失1秒钟的数据，而no模式的效率和everysec相仿，但是会丢失上次同步AOF文件之后的所有写命令数据。

#### AOF重写

**问题：**因为AOF持久化是通过保存redis服务器被执行的写命令来记录服务器的状态，所以随着时间的流逝，AOF文件内容会越来越多，文件体积也会越来越大。所以需要加以控制。

**解决：**通过AOF重写解决上述问题，通过该功能，Redis服务器可以创建一个新的AOF文件**替代**原先的AOF文件，新旧两个AOF文件包含的**数据库状态**相同，但是新的AOF文件不包含冗余命令。所以新的AOF文件要比旧的AOF文件小很多。

> 对新的AOF进行改名，**原子的**覆盖现有的AOF文件，完成新旧两个AOF文件的替换

具体实现：**aof_rewrite(new_aof_file_name)**方法

#### AOF后台重写

通过调用**aof_rewrite**方法实现AOF重写，但是因为涉及到大量的io操作，所以处于阻塞状态，通过辅助方法，也就是fork一个子进程用来执行AOF重写的过程，然后父进程可以继续执行命令请求。

1. 子进程执行AOF重写期间，父进程能够继续执行命令请求
2. **子进程带有数据副本，使用子进程而不是线程**，这样就避免使用锁，但也能保证数据的安全

**新的问题** ：子进程在执行AOF重写期间，父进程执行的命令可能包含了对数据的修改，这样就会导致重写后的AOF和当前的数据库状态不一致。

**如何解决：**

![image-20210409170618426](https://i.loli.net/2021/04/09/34FoG7ne2CgjbOx.png)

在子进程执行AOF重写期间，父进程会进行如下的操作

1. 父进程将执行后的写命令追加到AOF缓冲区
2. 父进程将执行后的写命令写入AOF重写缓冲区

这样保证了：

1. AOF缓冲区的内容会被定期的写入AOF文件
2. 从创建子进程开始，新的之后后的写命令会被记录到AOF重写缓冲区

**当子进程AOF重写结束之后，会向父进程发送信号，父进程接受到信号之后，调用信号处理函数，做如下内容**

1. 将AOF重写缓冲区的内容写入到新的AOF文件中，这样，新的AOF文件保存的数据库状态就和但前数据库状态一致了。
2. 对新的AOF进行改名，**原子的**覆盖现有的AOF文件，完成新旧两个AOF文件的替换

## Redis实现分布式锁

### 前言

在搞明白分布式锁之前，先明白其由来。

谈到分布式锁自然也就能联想到分布式应用。

1. 在将应用拆分为分布式应用之前，是单机系统，在单机系统中的并发场景为单进程多线程模式

   1. 采用加锁或者非阻塞同步或者无锁同步可以简单的实现同步操作

2. 将应用拆分为分布式应用之后，并发场景变成了多进程+多线程的模式

   业界常用的解决方案通常是借助于一个第三方组件并==利用它自身的排他性来达到多进程的互斥==。如：

   1. 基于DB的唯一索引
   2. 基于ZK的临时节点
   3. 基于Redis的NX EX参数
      - `EX second` ：设置键的过期时间为 `second` 秒。 `SET key value EX second` 效果等同于 `SETEX key second value` 。
      - `PX millisecond` ：设置键的过期时间为 `millisecond` 毫秒。 `SET key value PX millisecond` 效果等同于 `PSETEX key millisecond value` 。
      - `NX` ：只在键不存在时，才对键进行设置操作。 `SET key value NX` 效果等同于 `SETNX key value` 。
      - `XX` ：只在键已经存在时，才对键进行设置操作。

#### 可靠性

1. 互斥性。在任意时刻，只有一个客户端能持有锁。
2. 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
3. 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。
4. 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。

### 实现

#### 加锁操作

```java
@Slf4j
public class RedisTool {
    // 用于加锁
    private static final String LOCK_SUCCESS = "OK";
    // 用于设置 string操作的的参数，只在键不存在时，才对键进行设置操作
    private static final String SET_IF_NOT_EXIST = "NX";
    // 用于设置 键的过期时间
    private static final String SET_WITH_EXPIRE_TIME = "PX";
    private static final int DEFAULT_EXPIRE_TIME = 60;

    /**
     * 加锁操作
     * @param jedis
     * @param lockKey
     * @param requestId
     * @param expireTime
     * @return
     */
    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {
        expireTime = expireTime <= 0 ? DEFAULT_EXPIRE_TIME : expireTime;
        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);
        if (LOCK_SUCCESS.equals(result)) {
            log.info("get lock success, request_id {}", requestId);
            return true;
        }
        return false;
    }
}
```

1. 一条set操作是具有原子性的，可以保证同一时间段内，只有一个客户端获取锁
2. 设置了过期时间，所以不会出现已获取锁的客户端，异常退出后，其他客户端一直无法获取锁
3. value设置为request_id，可以在解锁阶段进行判断，解锁的请求是否是加锁的请求。

#### 解锁操作

```java
private static final Long RELEASE_SUCCESS = 1L;
/**
 * 解锁操作
 * @param jedis
 * @param lockKey
 * @param requestId
 * @return
 */
public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {
    String script = "if redis.call('get', KEYS[1]) == ARGV[1] " +
            "then return redis.call('del', KEYS[1]) else return 0 end";
    Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(reque
    if (RELEASE_SUCCESS.equals(result)) {
        log.info("release lock success, request_id {}", requestId);
        return true;
    }
    return false;
}
```

**lua脚本的意思**

- 首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性



### 一些小问题



#### 锁被错误解除（设置value = requestid原因）

如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。

<img src="/Users/weikunkun/Library/Application Support/typora-user-images/image-20210415180241606.png" alt="image-20210415180241606" style="zoom: 25%;" />

通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。



#### 超时解锁，导致并发（如何确定过期时间的大小）

A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：

- 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。
- 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。

<img src="/Users/weikunkun/Library/Application Support/typora-user-images/image-20210415180526821.png" alt="image-20210415180526821" style="zoom:25%;" />

#### 不可重入

当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。

在本地记录记录重入次数，如 Java 中使用 ThreadLocal 进行重入次数统计，简单示例代码：

```java
private static ThreadLocal<Map<String, Integer>> LOCKERS = ThreadLocal.withInitial(HashMap::new);
// 加锁
public boolean lock(String key) {
  Map<String, Integer> lockers = LOCKERS.get();
  if (lockers.containsKey(key)) {
    lockers.put(key, lockers.get(key) + 1);
    return true;
  } else {
    if (SET key uuid NX EX 30) {
      lockers.put(key, 1);
      return true;
    }
  }
  return false;
}
// 解锁
public void unlock(String key) {
  Map<String, Integer> lockers = LOCKERS.get();
  if (lockers.getOrDefault(key, 0) <= 1) {
    lockers.remove(key);
    DEL key
  } else {
    lockers.put(key, lockers.get(key) - 1);
  }
}

```

本地记录重入次数虽然高效，但如果考虑到过期时间和本地、Redis 一致性的问题，就会增加代码的复杂性。另一种方式是 Redis Map 数据结构来实现分布式锁，既存锁的标识也对重入次数进行计数。Redission 加锁示例：

```java
// 如果 lock_key 不存在
if (redis.call('exists', KEYS[1]) == 0)
then
    // 设置 lock_key 线程标识 1 进行加锁
    redis.call('hset', KEYS[1], ARGV[2], 1);
    // 设置过期时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
    end;
// 如果 lock_key 存在且线程标识是当前欲加锁的线程标识
if (redis.call('hexists', KEYS[1], ARGV[2]) == 1)
    // 自增
    then redis.call('hincrby', KEYS[1], ARGV[2], 1);
    // 重置过期时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
    end;
// 如果加锁失败，返回锁剩余时间
return redis.call('pttl', KEYS[1]);
```

#### 未获取锁的客户端，无法确定锁是否被释放

上述命令执行都是立即返回的，如果客户端可以等待锁释放就无法使用。

- 可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。
- 另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息。如下：

<img src="/Users/weikunkun/Library/Application Support/typora-user-images/image-20210415181101865.png" alt="image-20210415181101865" style="zoom:25%;" />





### 总结

==分布式锁，利用第三方组建自身的排他性，进而确保了多进程多线程之间的同步操作。Redis通过字符串操作的NX，PX参数，来保证自身的排他性。==





## **怎么实现Redis的高可用？**

要想实现高可用，一台机器肯定是不够的，而redis要保证高可用，有2个可选方案。

### **主从架构**

主从模式是最简单的实现高可用的方案，核心就是主从同步。主从同步的原理如下：

1. slave发送sync命令到master
2. master收到sync之后，执行bgsave，生成RDB全量文件
3. master把slave的写命令记录到缓存
4. bgsave执行完毕之后，发送RDB文件到slave，slave执行
5. master发送缓存中的写命令到slave，slave执行

![redis主从架构](https://i.loli.net/2021/03/19/E7KYOiA5RLaQ62t.jpg)





这里我写的这个命令是sync，但是在redis2.8版本之后已经使用psync来替代sync了，原因是sync命令非常消耗系统资源，而psync的效率更高。

### **哨兵**

基于主从方案的缺点还是很明显的，假设master宕机，那么就不能写入数据，那么slave也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。而哨兵(sentinel)的功能比单纯的主从架构全面的多了，它具备自动故障转移、集群监控、消息通知等功能。



![redis哨兵](https://i.loli.net/2021/03/19/9Z6QCq4pbxvBjFX.jpg)



哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。整个过程如下：

1. 初始化sentinel，将普通的redis代码替换成sentinel专用代码
2. 初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID
3. 创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道
4. 每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息
5. 当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，同时每个10秒发送info命令，更新master信息
6. sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态
7. 选举出领头sentinel，领头sentinel需要半数以上的sentinel同意
8. 领头sentinel从已下线的的master所有slave中挑选一个，将其转换为master
9. 让所有的slave改为从新的master复制数据
10. 将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器

sentinel会每隔1秒向所有实例（包括主从服务器和其他sentinel）发送ping命令，并且根据回复判断是否已经下线，这种方式叫做主观下线。当判断为主观下线时，就会向其他监视的sentinel询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。



## **能说说redis集群的原理吗？**

如果说依靠哨兵可以实现redis的高可用，如果还想在支持高并发同时容纳海量的数据，那就需要redis集群。redis集群是redis提供的分布式数据存储方案，集群通过数据分片sharding来进行数据的共享，同时提供复制和故障转移的功能。

### **节点**

一个redis集群由多个节点node组成，而多个node之间通过cluster meet命令来进行连接，节点的握手过程：

1. 节点A收到客户端的cluster meet命令
2. A根据收到的IP地址和端口号，向B发送一条meet消息
3. 节点B收到meet消息返回pong
4. A知道B收到了meet消息，返回一条ping消息，握手成功
5. 最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进行握手



![redis-节点](https://i.loli.net/2021/03/19/MlIVJt37jRO6CUb.jpg)



### **槽slot**

redis通过集群分片的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16383个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。

slot是一个位数组，数组的长度是16384/8=2048，而数组的每一位用1表示被节点处理，0表示不处理，如图所示的话表示A节点处理0-7的slot。



![redist-槽slot](https://i.loli.net/2021/03/19/CPMRVrKZL6whcNb.jpg)



当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执行命令，反之，则会返回一个MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是自动的）

![槽2](https://i.loli.net/2021/03/19/5PmfYv9l4Ebas3A.jpg)





如果增加或者移出节点，对于slot的重新分配也是非常方便的，redis提供了工具帮助实现slot的迁移，整个过程是完全在线的，不需要停止服务。

### **故障转移**

如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发生故障转移，优先从复制数据较多的从节点选择一个成为主节点，并且接管下线节点的slot，整个过程和哨兵非常类似，都是基于Raft协议做选举。



## **了解Redis事务机制吗？**

redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。事务的执行过程如下：

1. 服务端收到客户端请求，事务以MULTI开始
2. 如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令
3. 当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端

WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。



## references

* redis设计与实现
* 算法之美
* [面试必问的 Redis：RDB、AOF、混合持久化](https://zhuanlan.zhihu.com/p/340082703)
* [解决死锁之路](https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html)
* [MySQL索引背后的数据结构及算法原理](https://blog.codinglabs.org/articles/theory-of-mysql-index.html)
* [redis string](http://doc.redisfans.com/string/set.html)

