# JVM全书整理

可以理解为对深入理解JVM虚拟机的全本背诵:smile:

## Class文件内容

* [ ] [其他参考文章](https://mp.weixin.qq.com/s/pekAvJY84qSefHi69d3qgw)



## Java内存区域

Java虚拟机在运行时划分如下几个区域

![image-20210401164640850](https://i.loli.net/2021/04/01/GZb4oXfJS3BVOPm.png)

同时按照是否被线程独享，还可进行如下划分

![image-20210401164743086](https://i.loli.net/2021/04/01/8tPbshu6vgV7wC4.png)

### Java虚拟机运行时区域划分

#### 程序计数器

> **是否私有**： 线程私有
>
> **作用：** 用于记录线程当前运行到哪里，以确保线程切换后能恢复到正确的位置。
>
> **生命周期：** 随着线程的开始而开始，随着线程的结束而结束
>
> ==**不会出现任何OOM问题。**== 

#### Java虚拟机栈

> **是否私有：**线程私有
>
> **作用：** 是Java方法执行的内存模型：每个方法在执行时会在虚拟机栈上创建**栈帧** ，==每个方法从调用到结束都对应着栈帧的入栈和出栈。==
>
> 1. 栈帧
>
>    在方法执行阶段，局部变量表的大小是确定的。在编译阶段已经分配完成。
>
>    - 局部变量表
>      - 编译器可知的各种基础数据类型、引用对象
>    - 操作数栈
>    - 动态连接
>    - 方法出口
>    - ...
>
> **生命周期：** 和线程相同，随着线程开始而开始，结束而结束
>
> 物理地址连续
>
> ==**会出现StackOverflowError和OutOfMemoryError异常**==

#### 本地方法栈

> 是为JVM运行Native方法准备的空间。作用和Java栈类似。
>
> 虚拟机规范中没有对本地方法栈有严格的限制。
>
> 物理地址连续
>
> ==**会出现StackOverflowError和OutOfMemoryError异常**==

#### Java堆

> **是否线程私有:** 否
>
> **作用:** 用来存储对象实例
>
> **生命周期:** 由JVM管理
>
> Java堆是垃圾回收管理的主要区域。
>
> 1. 从==内存回收==的角度来看
>
>    可以将其划分**新生代**、**老年代**
>
>    再细致一些，还可以将**新生代**划分为**Eden空间**、**From Survivor空间**、**To Survivor空间**
>
> 2. 从==内存分配==的角度来看，还可以划分多个线程私有的分配缓冲区
>
> 无论如何划分，无论哪个区域，存储的都是对象的实例。进一步划分的目的是为了更好的进行垃圾回收。
>
> 同时JVM规范中规定，Java堆可以处于物理上不连续性的内存空间，只要逻辑上是连续性的即可。
>
> 堆中没有内存完成实例的分配，并且堆也无法进行拓展时，抛出OutOfMemoryError
>
> ==**会出现OutOfMemoryError异常**==

#### 方法区

> 方法区与堆空间类似，它也是被 JVM 中所有的线程共享的。用于存储虚拟机加载的`类信息`、`常量`、`静态变量`。
>
> JVM规范对方法区的限制非常宽松，除了和Java堆一样，不需要连续的内存空间和可以选择固定大小或者可拓展意外。还可以选择是否实现垃圾收集。该区域垃圾回收的主要内容包含：常量池的回收、类的卸载。
>
> ==**会出现OutOfMemoryError异常**==

1. 类型信息:
   1. 类的完整名称、
   2. 父类的完整名称、
   3. 类型修饰符
   4. 类型的直接接口类表；
2. 常量池(这个类方法、字段等信息所引用的常量信息)
   1. 字面量
      1. 文本字符串
      2. 常量(final修饰)等
   2. 符号引用
      1. 类和接口的全限定名
      2. 字段的名称和全限定名
      3. 方法的名称和全限定名
3. 字段信息
   1. 字段名称
   2. 字段类型
   3. 字段修饰符；
4. 方法信息
   1. 方法名称
   2. 返回类型
   3. 方法参数
   4. 方法修饰符
   5. 方法字节码
   6. 操作数栈
   7. 方法栈帧的局部变量区大小
   8. 异常表

**总之，方法区内保持的信息大部分来自于 class 文件，是 Java 应用程序运行必不可少的重要数据。**

==**运行时常量池**==

**比如：字符串，int -128~127 范围的值等，它是 Method Area 中的一部分。**

> 当Java文件被编译成class文件之后，也就是会生成上述的class常量池，那么运行时常量池又是什么时候产生的呢？
>
> JVM在执行某个类的时候，必须经过**加载、连接、初始化**，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，**JVM就会将class常量池中的内容存放到运行时常量池中**。同时Class常量池中存的是**字面量**和**符号引用**，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用, 与全局常量池中的引用值保持一致。

### 对象的创建过程

![new对象过程](https://i.loli.net/2021/03/19/hR3nSrNMJzGPTFL.jpg)

1. 首先判断该类是否加载
2. 在堆上分配内存空间
   - 如何分配内存空间
   - 如何确保分配内存空间的动作是线程安全的
     - 采用CAS配上失败重试的方式保证更新操作的原子性
     - 把内存分配的动作按照线程划分在不同的空间之中进行
       - 为每个线程在Java堆中预先分配一个小块内存。称之为本地线程分配缓冲区（TLAB）
       - 通过**-XX:+/-UseTLAB**参数来设定
3. 内存分配完毕之后，虚拟机将分配到的内存空间都初始化为零值（不包含对象头）
4. 设置对象头
   1. 设置对象类型（是哪个类的实例）
   2. 对象的hashcode、对象的GC分代年龄
   3. 锁信息
5. 经过以上四个步骤，从虚拟机的角度，一个新的对象产生了。但是从Java程序的角度来看，对象的创建才刚刚开始
6. \<init\>方法（构造函数？）还没有执行，当前所有的字段还都是**零值**，执行new命令之后，执行\<init\>方法，把对象按照程序员的意愿进行初始化。这样一个真正可用的对象才算完全产生出来。
7. 将对象的内存地址赋给引用

## 类加载器

### 类加载机制

**概述：**

> 虚拟机将描述类的数据从Class文件加载到内存，并对数据进行`验证`、`准备`、`解析`以及`初始化`，最终形成可以被虚拟机直接使用的Java类型。这就是类的加载机制

![image-20210401221740540](https://i.loli.net/2021/04/01/e6Xn3NaKM5qCyvu.png)

在JVM中并没有规定什么时候开始执行加载，但是初始化阶段，JVM进行了严格的规范

1. 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行初始化，需要先触发初始化
2. 对类进行反射调用的时候
3. 初始化一个类的时候，如果其父类没有被初始化，先将父类初始化
4. 虚拟机启动时，用户指定的一个执行类，mian方法对应的类



#### 加载

1. 通过一个类饿全限定名来获取定义此类的二进制流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个java.lang.Class对象，作为方法区中该类的各种数据的访问入口

#### 验证

确保Class文件的字节流中包含的信息符合虚拟机的要求，并且不会危害虚拟机本身。

#### 准备

1. 为static修饰的变量分配内存
2. 为static修饰的变量设置初始值（对应数据类型的零值）

#### 解析

1. 虚拟机将常量池内的**符号引用**替换为**直接引用**的过程
   - 符号引用
     - 在Class中对类, 接口, 方法的描述
   - 直接引用
     - 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机示例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在在内存中了。

#### 初始化

真正初始化类变量和其他数据。

关于通过静态内部类能实现单例模式的原因[深入理解单例模式](https://blog.csdn.net/mnb65482/article/details/80458571)

> 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。

### 类加载器

1. 从虚拟机的角度来看，只有两种类加载器：
   1. 一种是启动类加载器，该加载器由C++实现，是虚拟机自身的一部分
   2. 另一种就是其他所有的类加载器，这些类加载器都是由Java语言实现，独立于虚拟机外部，均继承自抽象类java.lang.ClassLoader
2. 从开发人员的角度来看，分为如下三种：
   1. 启动类加载器
      1. 负责将存放在\<JAVA_HOME\>\lib目录中的类库加载到虚拟机中
   2. 拓展类加载器
      1. 负责将存放在\<JAVA_HOME\>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库
   3. 应用程序类加载器
      1. 负责将用户路径上所指定的类库加载到虚拟机

#### 作用是什么

1. 用于判断两个类是否相同
   1. 全限定名是否相同
   2. 类加载器是否相同
2. 将类加载到JVM中
3. 审查每个类应该由谁加载

#### 有哪些类加载器

#### 双亲委派机制

**双亲委派模型：**

双亲委派模型要求除了启动类加载器，其余的类加载器都有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合的关系来复用父加载器的代码。

![image-20210401221719988](/Users/weikunkun/Library/Application Support/typora-user-images/image-20210401221719988.png)

> 当一个类加载器收到了类的加载请求时，其本身不会立即去加载该类，而是会将请求转交给父类加载器进行去完成。每一层的类加载器都是如此。所以所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类的加载器反馈自己无法完成这个类加载的请求，子类才会尝试自己去加载。



## GC

垃圾收集，所需要完成的3件事情：

1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收

**哪些需要内存回收：**

> 因为`程序计数器`、`Java虚拟机栈`、`本地方法栈`自身的特性，属于线程私有，并且随着线程的创建而创建，随着线程的结束而结束。并且栈中的栈帧都是随着方法的调用和结束而入栈和出栈。并且每个栈帧的内存大小都是在类结构确定的时候，确定的。所以这几个区域不需要考虑内存回收。但是对于堆上的实例对象，因为只有程序在运行期间才能知道会创建哪些对象，都是动态进行，所以主要的回收目标就这些。

![image-20210401191454885](/Users/weikunkun/Library/Application Support/typora-user-images/image-20210401191454885.png)



堆中存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，做的第一步就是判断对象是否**存活**

**那么如何判断存活**？

![image-20210401190830048](https://i.loli.net/2021/04/01/MFZeYOiDx5jS7cw.png)

> 引用计数法虽然能够实现判断对象是否存活的问题，但是对于循环引用，引用计数法很难解决
>
> > 通过强引用和弱引用可以解决

![image-20210401190846027](https://i.loli.net/2021/04/01/gkHaGRc7zNmTSu5.png)

> 还是刚才的循环引用问题（也是某些公司面试官可能会问到的问题)，如果 A 引用 B，B 又引用 A，这 2 个对象是否能被 GC 回收？
>
> 
>
> 答案：关键不是在于 A、B 之间是否有引用，而是 A、B 是否可以一直向上追溯到 GC Roots。如果与 GC Roots 没有关联，则会被回收，否则将继续存活。



![image-20210401191339866](https://i.loli.net/2021/04/01/FW1D46rlxKq3gCQ.png)

> 上图是一个用“可达性分析”标记垃圾对象的示例图，灰色的对象表示不可达对象，将等待回收。

### 引用类型

判断对象是否存活都和引用有关。我们希望能够描述这样一类对象：

> 当内存空间还足够的时候，能保留在内存中。如果内存空间在GC之后还是很紧张，则可以抛弃这些对象。

#### 强引用

也就是我们常用的new Object()这种类型，只要强引用还在，垃圾回收就不会触碰这些引用的对象。只有超过了引用的作用域或者显式地将相应（强）引用赋值为 null（JDK源码里面大量的置null操作），就是可以被垃圾收集的了

#### 软引用

是一种相对于强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有JVM认为内存不足的时候，才会去试图回收软引用指向的对象。==JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。==软引用通常用来实现==内存敏感的缓存==，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

#### 弱引用

并不能豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。

==这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。==

#### 虚引用

对于幻象引用，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，我在专栏上一讲中介绍的 Java 平台自身 Cleaner 机制等，也有人利用幻象引用监控对象的创建和销毁。

### 方法区的回收

方法区的垃圾回收主要是两类：**废弃的常量**、**无用的类**

1. 废弃的常量

   1. 判断方法和对象是否存活一样

2. 无用的类

   1. 该类所有的实例已经被回收，即Java堆中不存在该类的任何实例
   2. 该类对应的类加载器已经被回收
   3. 该类对应的java.lang.Class对象没有在任何地方被引用，也就确保了无法在任何地方通过反射访问该类的方法

   符合以上条件的类，也仅仅是可能被回收，是否回收还是需要看JVM自身

### GC算法有哪些

#### 标记清除算法

![image-20210401193449224](https://i.loli.net/2021/04/01/haE65cn3mA1lVXu.png)

共分为两个阶段：标记、清除

1. 将待清理的垃圾对象标记出来
2. 统一回收所有被标记的对象。

**优点：** 最基础的收集算法，实现简单

**缺点：** 

1. 效率不高，标记和清除两个步骤效率都不高
2. 空间问题，内存利用率不高，清除之后，会产生大量的内存碎片。

#### 复制算法

将可用内存划分为大小相等的两块儿，每次只使用一块儿，当这块儿用完之后，将存活的对象复制到另一块儿上，然后统一清除这一块儿上的所有对象。

**优点** ：避免了内存碎片

**缺点：** 内存利用率不高

#### 标记整理算法

在标记清除的基础上，将垃圾清理之后，还会将存活的对象进行整理挪动，保持它们占用连续的内存空间。

**优点：**

1. 避免了内存碎片

**缺点：**

1. 整理过程会降低GC效率

#### 分代收集算法

根据对象存活周期的不同将内存划分为新生代、老年代。这样根据各个年代的特点采用最适当的算法。

1. 新生代

   每次垃圾收集都会有大量的对象不可用，只有少量的存活。所以就使用复制算法，只需要复制少量的存活对象就能完成收集。

2. 老年代中因为对象存活率高，所以使用标记清除/标记整理算法来进行回收。

### 具体的垃圾回收器

#### CMS

整体流程

1. 初始标记

   仅标记GC Roots 能直接关联到的对象，速度快

2. 并发标记

3. 重新标记

4. 并发清理

**优点：**

**缺点：**

1. CPU敏感

2. 无法处理浮动垃圾

   并发清理阶段产生垃圾，无法回收，只能等到下一次GC是才能清除。

3. CMS是基于标记-清除算法的收集器，会产生大量的内存碎片。

#### G1

* [ ] TODO



#### GC过程

1. 正常情况新建的对象会被分配到Eden区，然后From Survivor空间、 To Survivor空间是空着的
2. 当Eden区放不下的时候, 就会出发minor GC, 首先标记出Eden区的不可达对象(黄色),  然后将可达对象移动到From Survivor区域, 将不可达对象删除, 之后, Eden区域就为空了(这里其实已经综合运用了“【标记 - 清理 eden】 + 【标记 - 复制 eden->s0】”算法)
3. 随着时间的推移, Eden区域被填满了, 然后触发minor GC, 然后标记出Eden区和From Survivor区的可达对象, 然后将他们移动到To Survivor区, 之后将不可达对象删除, 此时 Eden区和From Suvivor区都被为空了, 只有 To Suvivor区域有存活对象 
4. 继续，随着对象的不断分配，eden 空可能又满了，这时会重复刚才的 minor GC 过程，不过要注意的是，这时候From Survivor是空的，所以From Survivor与To Survivor 的角色其实会互换，即：存活的对象，会从 eden 和To Survivor 区，向From Survivor区移动。然后再把 eden 和To Survivor区中的垃圾清除，这一轮完成后，eden 与 From Survivor 区变成空的
5. 对于那些比较“长寿”的对象一直在 s0 与 s1 中挪来挪去，一来很占地方，而且也会造成一定开销，降低 gc 效率，于是有了“代龄 (age)”及“晋升”
6. 对象在年青代的 3 个区 (edge,s0,s1) 之间，每次从 1 个区移到另 1 区，年龄 +1，在 young 区达到一定的年龄阈值后，将晋升到老年代。下图中是 8，即：挪动 8 次后，如果还活着，下次 minor GC 时，将移动到 Tenured 区
7. 如果老年代，最终也放满了，就会发生 major GC（即 Full GC），由于老年代的的对象通常会比较多，因为标记 - 清理 - 整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，这也是为什么很多应用要优化，尽量避免或减少 Full GC 的原因



