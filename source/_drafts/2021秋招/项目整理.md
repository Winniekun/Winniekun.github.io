## 整理过程

1. 背景
2. 为什么做，场景是啥，解决问题的特性是什么
3. 技术选型

## 项目设计的初期，没有对整个体系有规划

1. 对数据查询的考虑
2. 对接口调用的整合



## 项目中

1. 项目背景
2. 突出做的内容，解决的难题是什么
   1. 遇到问题
   2. 有什么方法可以解决
   3. 最后选择了什么方法
3. 最后项目的收益



## 项目整体的总结

简历上的两个实习项目，近乎是自己完全负责的项目，经验知识库调用其他服务接口时的token生成自己未实现，联联换电站的订单小结推送，之前已经实现，只是添加联联需要的字段而已，最后，因为联联推送要求，共分为两次，一次是业务的推送，还有一次是政府补贴推送，两个推送不能混为一谈。对内部枪、站编码转对外枪、站编码逻辑复杂，可以编写单元测试。

整体来讲：

**侧重点**

1. 联联换电站逻辑复杂，使用的技术栈多
2. 经验知识库，主要是sql编写复杂，对数据的校验严格

**共同点**

1. 都需要调用外部接口，所以对于接口的超时处理需要进行处理

### 联联换电站

#### 整体逻辑

![image-20210417183424430](https://i.loli.net/2021/04/17/1Pk3EjJ98cOFdTH.png)

![image-20210417190013656](https://i.loli.net/2021/04/17/jSKHtNQnwZR9Ogp.png)

![image-20210417234607474](https://i.loli.net/2021/04/17/KgRyoDabxkFptqW.png)

#### 整体流程

1. 三方扫码充电
2. 校验信息，符合要求，落库
   1. ==记录启动换电开始==  value 
3. 三方app点击请求开始充电，然后监听换电站上报信息
   1. 如果上报信息为充电中，但是表中无启动充电的订单，则视为内部订单，直接进入充电中
      1. ==记录开始换电订单==
   2. 如果上报信息为充电中，表中存在启动充电的订单，无充电中的订单，则绑定和联联订单
      1. ==清除启动开始订单（单个id）==
   3. 推送开始换点成功消息
4. 三方发起结束充电，返回订单当前的状态
5. 监听换点结束消息
   1. 计算价格，推送订单最后的订单小结，包含费用的计算
   2. ==清理缓存中结束的订单（单个id）==
   3. 推送订单小结

#### 订单异常判断

![image-20210417234607474](https://i.loli.net/2021/04/17/KgRyoDabxkFptqW.png)

1. 启动开始之后，超过5分钟未进入开始换电视为启动异常，对应订单进入异常状态
2. 换电开始之后，超过60分钟未进入换电未结束，对应订单进入异常状态



#### 数据校验

1. 在专员扫码前，会进行二维码里的信息进行校验

   1. 换电站是否租赁给联联
   2. 然后检测，换电站电池是否有可用电池
   3. ...

2. 在接收到启动换点命令时，检测该换电站是否有处于启动中、换电中的订单，并且该订单号不存在于数据库中。

   1. ==订单号==为一个高频的查询字段
   2. 正常落库，订单状态变为启动中

3. 在接收到开始换电命令时，检测该换电站是否有处于启动中的订单

   1. 不存在，创建内部订单，订单状态改为充电中
   2. 存在，绑定联联的订单
   3. ==device_id 和 status 联合查找==

   

#### 异常状态的设置

1. redis和定时任务的结合
   1. redis中使用zeset添加数据库中记录的主键id，以秒为单位进行排序。
   2. 之后使用spring @scheduler 执行定时任务，每隔分钟统计一次是否存在异常订单。
      1. 保证线程的安全，使用了分布式锁

#### 推送逻辑

1. 开始充电，进行推送
2. 结束充电，进行推送

创建了线程池，16核心线程，16非核心线程

#### 单元测试

因为是接出业务，不同的三方平台，对于充电设备的编码命名规范不同，在接出之前，需要将充电设备命名转化为符合对应三方的命名规范，然后接入时，通过再转化为符合蔚来内部的设备名称编号（设备类型简称-运营商简称-8位随机字符串-8位随机字符串），所以在在进行

### 经验知识库

#### 如何建立表

<img src="/Users/weikunkun/Library/Application Support/typora-user-images/image-20210422093918664.png" alt="image-20210422093918664" style="zoom:50%;" />

#### 分页如何实现

#### 复杂SQL如何编写

**思路**

要求为：对于一种异常码可能所有的设备商或者所有的设备都适用，然后会使用ALL字段来表示所有，在查询的时候，如果有符合ALL的查询，必须返回all，然后如果一个ALL已经对应了一个异常码，则该异常码不能够被新增其他的设备，但是可以修改为部分运营商的。

存在四种情况

|                                    |                                   |
| ---------------------------------- | --------------------------------- |
| operatorId 为all，deviceID为all    | operatorId不为all，deviceId为all  |
| operatorId 为all， deviceId不为all | operatorId不为all， device不为all |



```xml
<select id="selectChargeAbnormalWithOperatorListOrDeviceListAll"
        resultMap="BaseResultMap">
        select caci.id, caci.step, caci.event_code, caci.error_code, caci.error_message,
            oacri.operator_id,
            acdmr.device_model
        from charge_abnormal_code_info caci
        left join operator_abnormal_code_relation_info oacri on oacri.abnormal_code_id = caci.id and oacri.deleted = 0
        left join abnormal_code_device_model_relation_info acdmr on acdmr.abnormal_code_id = caci.id and acdmr.deleted = 0
        where caci.deleted = 0
        <if test="step != null">
            and caci.step = #{step}
        </if>
        <if test="eventCode != null">
            and caci.event_code = #{eventCode}
        </if>
        <if test="errorCode != null">
            and caci.error_code = #{errorCode}
        </if>
        <if test="id != null">
            and caci.id != #{id}
        </if>
        and (
        <choose>
            <when test="deviceModelIsAll == false and operatorIdIsAll == false">
                acdmr.device_model in
                <foreach collection="modelList" item="item" open="("
                    separator="," close=")">
                    #{item}
                </foreach>
                and oacri.operator_id in
                <foreach collection="operatorList" item="item" open="("
                    separator="," close=")">
                    #{item}
                </foreach>
            </when>
            <when test="deviceModelIsAll == false">
                acdmr.device_model in
                <foreach collection="modelList" item="item" open="("
                    separator="," close=")">
                    #{item}
                </foreach>
                <if test="operatorIdIsAll == false">
                    <if test="operatorList != null and operatorList.size() > 0">
                        or oacri.operator_id in
                        <foreach collection="operatorList" item="item" open="("
                            separator="," close=")">
                            #{item}
                        </foreach>
                    </if>
                </if>
            </when>
            <when test="operatorIdIsAll == false">
                oacri.operator_id in
                <foreach collection="operatorList" item="item" open="("
                    separator="," close=")">
                    #{item}
                </foreach>
                <if test="deviceModelIsAll == false">
                    <if test="operatorList != null and operatorList.size() > 0">
                        or acdmr.device_model in
                        <foreach collection="modelList" item="item" open="("
                            separator="," close=")">
                            #{item}
                        </foreach>
                    </if>
                </if>
            </when>
            <otherwise>
                1 = 1
            </otherwise>
        </choose>
        )
    </select>
```



#### 如何使用策略模式+泛型实现调用统一

1. 使用feign调用内部服务的接口
2. 内部编写一个服务类，用于将调用接口返回的信息封装入DTO中，同时处理调用超时、返回数据错误等问题
3. 后序采用策略模式的思想使用泛型写了一个调用内部服务类的方法invokeCecClient，根据不同的请求URL，去调用内部服务类的不同方法
4. 以上处理完之后，简化了上层的接口调用的，但是token问题还没有处理，最后在调用invokeCecClient之前，会先根据缓存中是否包含有对应的token，然后去获取token的值（token是根据域账号使用加密算法获取的）。
   1. 如果没有，则生成token，然后存入redis中，使用分布式锁，来确保token生成的正确性
   2. 如果有，直接获取。

## 统一 接口超时如何处理

对其他服务接口的调用，本质上是一次http协议进行的一次网络请求。网络请求必然有超时的可能性，所以需要考虑以下三点

1. 框架设置的超时时间是否合理
2. 其次，考虑到网路不稳定的原因，超时之后的重试是有必要的，但是需要做幂等的处理
3. 最后，考虑框架对并发连接数量的控制。避免服务在高并发情况下，http调用成为瓶颈
4. 



