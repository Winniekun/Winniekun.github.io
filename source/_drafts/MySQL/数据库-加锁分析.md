# SQL锁分析

## 前言

只有对平时执行的SQL的加锁过程了如指掌，才能在遇到死锁的时候，倒推出是什么锁导致的问题。在阐述MySQL中的锁的时候，了解到了锁模式和锁类型。我们要特别注意它们的兼容矩阵，熟悉哪些锁是不兼容的，这些不兼容的锁往往就是导致死锁的罪魁祸首。

总体来说，MySQL中的锁可以分成两个粒度：

1. 表锁
   1. 表级读锁
   2. 表级写锁
   3. 读意向锁
   4. 写意向锁
   5. 自增锁
2. 行锁
   1. 读记录锁
   2. 写记录锁
   3. 间隙锁
   4. Next-Key锁
   5. 插入意向锁

## 基本的加锁规则

虽然 MySQL 的锁各式各样，但是有些基本的加锁原则是保持不变的，譬如：快照读是不加锁的，更新语句肯定是加排它锁的，RC 隔离级别是没有间隙锁、next-key锁等等。这些规则整理如下，后面就不再重复介绍了：

1. 常见的语句加锁
   * select ...   
     * 正常情况下为快照读，不加锁
   * select ... lock in share mode
     * 加读锁
   * select ... for update 
     * 加写锁
   * 常见DML（insert、update、delete）
     * 为当前读，加X锁
   * 常见的DDL（alter、create）加表级锁
2. 表锁
   1. 表锁（分为S、X锁）
   2. 意向锁（分为IS、IX锁）
   3. 自增锁
3. 行锁
   1. 记录锁（分为S、X锁）
   2. 间隙锁（分S、X锁）
   3. Next-Key锁（分S、X锁）
   4. 插入意向锁
4. 行锁分析
   1. 行锁都是加在索引上的，最终都会落在聚簇索引上
   2. 加行锁的过程是一条一条记录加的
5. 锁冲突
   1. S锁和S锁兼容，X锁和X锁兼容，X锁和S锁不兼容
   2. 表锁和行锁的冲突矩阵
6. 不同隔离级别下的锁
   1. 序列化隔离级别的时候，select .... 为当前读，加S锁
   2. RC 隔离级别下没有间隙锁和 Next-key 锁（特殊情况下也会有：purge + unique key）；

