# 前言

仅阐述不同隔离级别的实现，关于几个隔离级别的阐述以及其能够解决的问题，不做阐述。

# 实现

在SQL的标准中，我们知道在**可重复读**的级别下是无法解决幻读现象的。

1. [Innodb 中 RR 隔离级别能否防止幻读？](https://github.com/Yhzhtk/note/issues/42)
2. [MySQL的InnoDB的幻读问题](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)

## 示例

其实对于幻读的理解，感觉还是有一些不一致。个人目前的理解是这样：

- 同一个事物内，同样的条件，前后读取返回的结果集不同
  - **结果集**

主要的原因是其他事物在该事物执行期间，执行了insert or delete操作。

根据以上的理解，在重新理解**引用2**中的示例：

#### 示例1

事物1和事物2的隔离级别均为可重复读，事物1在事物2提交之后，再次读取，没有记录，然后执行**insert**操作。报了主键冲突

![image-20210306111502197](https://i.loli.net/2021/03/06/rlivPtIFdWN2qjf.png)

但是，当我们再次读取的时候，发现发现仍然没有记录

![image-20210306111607027](https://i.loli.net/2021/03/06/SfWHxDgUBN3OMpm.png)

那么按照**幻读**的理解来讲，这并不属于幻读现象。

#### 示例2

事物1在事物2提交之后，修改了数据，但是发现修改了两行数据，但是在**修改之前读取的只有一行数据**，**修改之后读取却发现了两条数据**

![image-20210306112202452](https://i.loli.net/2021/03/06/dHtPo6aKm7INBvy.png)

这个根据定义来说，的确是发生了幻读，但是关键是，在两个select之间执行了**update**操作。update和insert一样，执行之后会更新当前事物的版本号，后序的select使用的最新的版本号进行快照读了。这么说的话，其实是和两个**select**之间执行一个**insert**是一个意思。这也属于幻读么？



#### 小总结

对于MySQL在RR隔离级别下是否解决了幻读，我认同**引用1**中的阐述

> 对于Innodb，Repeatable Read (RR) 针对当前读，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，**不存在幻读现象**。
>
> 官网求证也是如此：
>
> > For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE), UPDATE, and DELETE statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition. For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it. For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key locks to block insertions by other sessions into the gaps covered by the range.
>
> 大致意思就是，在 RR 级别下，如果查询条件能使用上唯一索引，或者是一个唯一的查询条件，那么仅加行锁，如果是一个范围查询，那么就会给这个范围加上 gap 锁或者 next-key锁 (行锁+gap锁)。

读在MySQL中本身就有歧义，因为其包含有**快照读**和**当前读**。幻读中的**读**是快照读？当前读。

1. 如果是快照度。MySQL中，通过版本号来保证同一事物里每次查询得到的结果集都是一致的
2. 如果是当前度。MySQL中，通过Next-key locks保证其他事物无法插入新的数据，从而避免幻读。

当然，如果一会儿是**快照读**一会儿是**当前读**。这也就莫得办法了。



## 传统的隔离级别

SQL规范中定义的四个隔离级别，分别是为解决并发情况下，事物可能会出现的几种问题。但是关于如何解决，解决方式是什么，并未指明。锁作为最简单明了的实现方式被每一个开发人员所熟知。所以一般在讨论隔离级别的时候都会带上该隔离级别的加锁方式是什么样的。但对于隔离级别的实现并不是只有锁一个方式，除了锁，解决事物的并发问题还有时间戳、多版本控制等，我们称之为**无锁的并发控制**

> 其实道理是和Java中实现线程安全是类似的，实现方式有多种：加锁，cas

传统的隔离级别基于锁来实现。也称为**基于锁的并发控制（LBCC）**。通过对读写操作加不同的锁，以及对释放锁的时机进行不同的控制，就可以实现四种隔离级别。

数据库中传统的锁有两种： 

1. 排它锁（X锁、写锁）
   1. 加了排它锁的**记录**，其他事物不能进行读、写
2. 共享锁（S锁、读锁）
   1. 加了共享锁的**记录**，其他事物可读，不能写

同时锁的粒度不同分为

1. 表锁
   1. 锁整张表
2. 行锁
   1. 锁记录

### 四种隔离级别加锁策略

- 读未提交
  - 事物读不阻塞其他事物读和写
    - 对写操作加**持续X锁**
    - 对读操作**不加锁**
- 读已提交
  - 事物读不阻塞其他事物读和写，事物写会阻塞其他事物读和写
    - 对写操作加**持续X锁**
    - 对读操作加**临时S锁**
- 可重复读
  - 事物读会阻塞其他事物写单不阻塞读，事物写会阻塞其他事物读和写
    - 对写操作加**持续X锁**
    - 对读操作加**持续S锁**
- 序列化
  - 直接使用表锁

### 小总结

通过对锁的类型（读\写锁）、锁的粒度（行锁\表锁）、持有锁的时间（持续\临时）进行组合，就能实现四种不同的隔离级别。