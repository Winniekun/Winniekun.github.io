---
title: translation
date: 2020-06-07 21:17:04
tags: 事物
categories: MySQL
thumbnail:
---

# 事物

事物是数据库的一大特性。事物会将数据库从==一种一致性态转移到另一种一致状态==。可以有一条简单的sql构成，也可以由一组复杂的sql组成，==同时事物也是是访问并修改数据库中数据的基本单位==。在事物中，所有命令要么全部执行成功，要么就全部都不执行。这时事物的目的。事物有四大特性：原子性（Atomicity）、一致性（consisstency）、隔离型（isolation）、持久性（durability）。

## 原子性

原子性表示，整个数据库事物是==不可分割的工作单位==，只有使事物事物中所有的数据库操作都执行，才算是整个事物成功。事物中任何一条sql执行失败，已经执行成功的sql语句也必须要撤销。

## 一致性

一致性表示将数据库中的数据从一个状态转移到下一种一致性状态。在执行前后==数据库的完整性约束没有被破坏==

> 表中的名字字段为唯一约束，若是在事物执行之后，表中的名字变得不唯一了，也就表明了事物将数据库从一种状态变为了一种不一致的状态。

## 隔离性

隔离性表示，==一个事物内的操作，对于其他的事物是不可见的==。

隔离型主要规定了各个事物之间相互影响的程度。

- 要求每个读写事物的对象对其他事物的操作对象能相互分离，也就是该事物提交前对其他事物都不可见，通常通过锁来实现。
- 设立了不同程度的隔离级别，通过适度的破坏一致性，得以提高性能

## 持久性

事物一旦提交，其结果就是永久性的。



# 事物的实现

事物的隔离型通过锁来实现，（对锁的类型（读\写锁）、锁的粒度（行锁\表锁）、持有锁的时间（持续\临时）进行组合）

原子性、一致性、持久性通过数据库中的redo log和undo log来实现。

![image-20210327191437023](https://i.loli.net/2021/03/27/FSX2HPVQTOqr97M.png)



## 原子性

由上述的介绍可知，事物的操作是最小的工作单位，一个事物中对于数据库中数据的操作，只有全部操作都执行成功才视为成功，任何一个操作执行失败，其他的操作也需要撤销。这里有两点

1. 执行成功，数据持久化
2. 执行不成功，回退事物开始前的状态

**这里就需要通过WAL（先写日志）来实现了。**

> **为什么要先写日志**
>
> > 1. 通过日志保证数据的正确性，而不是通过数据保证数据的正确性。
> > 2. 日志是顺序写的，非常快。数据，是随机写的，数据如果非常分散。效率会低得一塌糊涂。
> > 3. 简单点说。数据可以延后写，日志却不行。
> > 4. 因为数据相对于日志，是根本不重要的。它并不决定数据的安全。
>
> **为什么日志是顺序写**
>
> > 1、为什么日志是顺序io而innodb数据文件不是？ ==日志的写入是顺序追加的==，而文件的写入通常包括==写数据（写聚簇索引）==、==写索引（普通索引==）。所以一般不可能在同一个文件中顺序写入。
> >
> > 2、一个磁盘里多个进程写多个大文件，日志还是顺序读写吗？对于单独一个文件来说，依旧是顺序写。如果进程够多，整体的写入仍然随机，性能也并不会提升很多。
> >
> > 3、4、 如果innodb和日志一样只增加不修改不删除，它会是顺序写吗？如果你指的是innodb引擎，仍然不会是完全的顺序写，因为要写数据和索引。如果你有自增主键，并且没有其他索引的情况下，这个会好很多，因为自增主键会保证写入的多在B+树的最右侧，同时写入的尽量在一个page内
> >
> > 5、顺序/顺序读、随机写/读 并不必然是同时出现。比如RocksDB的引擎，因为结构是LSM树，所以写入是顺序的，但是读取并不是。

每一个写事物，都会修改bufferPool，从而产生响应的Redo/Undo日志，这些日志信息会被记录到日志文件中。在MySQL中，任何Buffer Pool中的页被刷到磁盘之前，都会写入到日志文件中，如果Buffer Pool 中的数据提交，此时数据库挂了，那在数据库再次启动之后，可以通过Redo 日志将其恢复，以保证脏页写的数据不会丢失。如果数据没有提交，此时数据库挂了，通过undo日志来实现。



## 持久性

redolog在系统crash重启之类的情况时，可以修复数据，从而保障事物的持久。通过持久性可以保障逻辑的持久性，通过存储引擎的数据刷盘可以保证物理上的持久性。



## 一致性

### undo log

重做日志记录了事物的行为，可以很好的通过其对页进行重做操作。但是事物有时还需要进行回滚操作，这时需要的就是undo log。mvcc





## 隔离性

通过MVCC技术和锁用于保障隔离性

> **在 InnoDB 存储引擎中，SELECT 操作的不可重复读问题通过 MVCC 得到了解决，而 UPDATE、DELETE 的不可重复读问题通过 Record Lock 解决，INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。**

### 一致性非锁定读

> 当前读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上的锁释放，而是读取行的一个最新可见快照。



## MySQL三大日志

日志是`MySQL`数据库的重要组成部分，记录着数据库运行期间各种信息状态。日志主要包含`错误日志`、`查询日志`、`慢查询日志`、`事务日志`、`二进制日志`几大类。当然作为开发，我们重点需要关注的是二进制日志(`binlog`)、事务日志(`redo log`、`undo log`)

### binlog

**作用：** 用于记录数据库执行的写入操作（**不包括查询**），以二进制的形式保存在磁盘中。其是`mysql`中的逻辑日志，并且由`server`层进行记录。所以任何的存储引擎mysql都会进行记录

* 逻辑日志
* 物理日志

**实现：** 通过追加的方式进行写入，可以通过`max_binlog_size `参数设置每个 `binlog`文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。

**使用场景：**

1. 主从复制

   在 `Master `端开启 `binlog `，然后将 `binlog `发送到各个 `Slave `端， `Slave `端重放 `binlog `从而达到主从数据一致。

2. 数据恢复

   通过mysqlbinlog工具恢复数据

#### binlog刷盘时机

对于 `InnoDB `存储引擎而言，只有在事务提交时才会记录 `biglog `，此时记录还在内存中，那么 `biglog`
是什么时候刷到磁盘中的呢？ `mysql `通过 `sync_binlog `参数控制 `biglog `的刷盘时机，取值范围是 `0-N`
：

- 0：不去强制要求，由系统自行判断何时写入磁盘；
- 1：每次 `commit `的时候都要将 `binlog `写入磁盘；
- N：每N个事务，才会将 `binlog `写入磁盘。

从上面可以看出， `sync_binlog `最安全的是设置是 `1 `，这也是 `MySQL 5.7.7`
之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。

### redo log

#### 为什么需要redo log

对于持久性来说，只要事物提交成功，那么对数据库做的修改都会保存下来。如何保证一致性？最简单的方式就是在每次执行事物提价的时候，将事物涉及修改的数据页全部刷新到磁盘中

1. InnoDB中，以页为单位进行交互，而一个事物可能只修改了该页上的一部分数据。这时候将整个数据页刷到磁盘中，就太浪费了。
2. 一个事物可能修改了多个页的内容，并且这些页对应的磁盘的物理空间可能并不连续，使用随机IO写入性能太差了。

使用redo log ， 也就是记录事物对数据页的修改，这样就能完美的解决性能问题

#### 基本概念

`redo log `包括两部分：一个是内存中的日志缓冲( `redo log buffer `)，另一个是磁盘上的日志文件( ` redo log
file `)。 `mysql `每执行一条 `DML `语句，先将记录写入 `redo log buffer `，后续某个时间点再一次性将多个操作记录写到 `redo log file `。这种 **先写日志，再写磁盘** 的技术就是 `MySQL`里经常说到的 `WAL(Write-Ahead Logging) `技术。

在计算机操作系统中，用户空间( `user space `)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( `
kernel space `)缓冲区( `OS Buffer `)。因此， `redo log buffer `写入 `redo log
file `实际上是先写入 `OS Buffer `，然后再通过系统调用 `fsync() `将其刷到 `redo log file `
中，

### redo log与binlog区别

|          | redo log                                                     | binlog                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 文件大小 | `redo log `的大小是固定的。                                  | `binlog `可通过配置参数 `max_binlog_size `设置每个` binlog `文件的大小。 |
| 实现方式 | `redo log `是 `InnoDB `引擎层实现的，并不是所有引擎都有。    | `binlog `是 `Server` 层实现的，所有引擎都可以使用 `binlog `日志 |
| 记录方式 | redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。 | binlog通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上 |
| 适用场景 | `redo log `适用于崩溃恢复(crash-safe)                        | `binlog `适用于主从复制和数据恢复                            |

由 `binlog `和 `redo log `的区别可知： `binlog `日志只用于归档，只依靠 `binlog `是没有 `
crash-safe `能力的。但只有 `redo log `也不行，因为 `redo log `是 `InnoDB `
特有的，且日志上的记录落盘后会被覆盖掉。因此需要 `binlog `和 `redo log`
二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。