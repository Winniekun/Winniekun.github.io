# 锁

1. **锁类型**就是表锁和行锁两种类型，当然行锁还可以细分成记录锁和间隙锁等更细的类型，锁类型描述的锁的粒度，也可以说是把锁具体加在什么地方

2. **锁模式**描述的是到底加的是什么锁，譬如读锁或写锁。锁模式通常是和锁类型结合使用的

## 表锁和行锁

- 表锁
  - 开销小，加锁块，不会出现死锁；锁的粒度大，但是锁冲突的概率高，并发量低。
- 行锁
  - 开销大，加锁慢，会出现死锁；锁的粒度小，但是锁冲突的概率低，并发量低。



### 表锁

### 行锁

行锁也可以分为两种：

1. 读锁
2. 写锁

常见的**增删改**会自动对操作的数据加写锁。查的时候也可以明确指定锁类型

```sql
select ... lock in share mode; -- 读锁
select ... for update -- 写锁
```

虽然行锁这个名字听起来是这个锁加在某个数据行上，实际为： 在MySQL中，**行锁是加在索引上的**



#### 行锁种类

根据锁的粒度可以把锁细分为表锁和行锁，行锁根据场景的不同又可以进一步细分，在 MySQL 的源码里，定义了四种类型的行锁，如下：

* LOCK_ORDINARY： 也称为Next-Key Lock
  * 锁一条记录及其之间的间隙
* LOCK_GAP: 间隙锁，
  * 锁两个记录之间的GAP，防止记录插入
* LOCK_REC_NOT_GAP：记录锁
  * 只锁记录
* LOCK_INSERT_INTENSION：插入意向GAP锁，
  * 插入记录时使用，是LOCK_GAP的一种特例



## 读锁和写锁

MySQL 将锁分成两类：锁类型（lock_type）和锁模式（lock_mode）。锁类型就是上文中介绍的表锁和行锁两种类型，当然行锁还可以细分成记录锁和间隙锁等更细的类型，锁类型描述的锁的粒度，也可以说是把锁具体加在什么地方；而锁模式描述的是到底加的是什么锁，譬如读锁或写锁。锁模式通常是和锁类型结合使用的，锁模式在 MySQL 的源码中定义如下：

- LOCK_IS：读意向锁；
- LOCK_IX：写意向锁；
- LOCK_S：读锁；
- LOCK_X：写锁；
- LOCK_AUTO_INC：自增锁；

**将锁分为读锁和写锁主要是为了提高读的并发，如果不区分读写锁，那么数据库将没办法并发读，并发性将大大降低**。而 IS（读意向）、IX（写意向）只会应用在表锁上，**方便表锁和行锁之间的冲突检测。**LOCK_AUTO_INC 是一种特殊的表锁。





### 读写意向锁

表锁是锁定了整张表，行锁是锁定表中的某条记录。两者肯定有交集，所以表锁和行锁之间是有冲突的。

**譬如：**

某个表有10000条记录，其中有一条记录加了X锁，如果这个时候系统需要对该表加表锁。在校验阶段会先遍历所有的10000条记录。查看是否有行锁。如果有则禁止加表锁。为了方便检测表锁和行锁的冲突。从而引进了**意向锁。**

意向锁为表级锁，也可分为读意向锁（IS 锁）和写意向锁（IX 锁）。当事务试图读或写某一条记录时，会先在表上加上意向锁，然后才在要操作的记录上加上读锁或写锁。这样判断表中是否有记录加锁就很简单了，只要看下表上是否有意向锁就行了。意向锁之间是不会产生冲突的，也不和 AUTO_INC 表锁冲突，它只会阻塞表级读锁或表级写锁，另外，意向锁也不会和行锁冲突，行锁只会和行锁冲突。



## 一些锁的详细阐述

刚开始学习数据库锁的的时候，理解的行锁就是将锁锁在一个行上，然后这一行的记录不能被其他人修改。这种理解其实是很肤浅的。因为行锁还可以锁在行与行之间的间隙上。

### 记录锁

刚才的肤浅的理解就是记录锁的定义

```sql
mysql> udpate accouts set level = 100 where id = 5;
```

这条 SQL 语句就会在 id = 5 这条记录上加上记录锁，防止其他事务对 id = 5 这条记录进行修改或删除。记录锁永远都是加在索引上的，就算一个表没有建索引，数据库也会隐式的创建一个索引。如果 WHERE 条件中指定的列是个二级索引，那么记录锁不仅会加在这个二级索引上，还会加在这个二级索引所对应的聚簇索引上

> 如果 SQL 语句无法使用索引时会走主索引实现全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁。如果一个 WHERE 条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由 MySQL Server 层进行过滤。不过在实际使用过程中，MySQL 做了一些改进，在 MySQL Server 层进行过滤的时候，如果发现不满足，会调用 unlock_row 方法，把不满足条件的记录释放锁（显然这违背了二段锁协议）。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见在没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，而且极大的降低了数据库的并发性能，所以说，更新操作一定要记得走索引。

### 间隙锁

在MySQL中通过**间隙锁**是的在可重复读的隔离级别下，避免了幻读的现象。

**概念**：间隙锁是加在两个索引之间的锁，或者是第一个索引之前，或者最后一个索引之后的间隙。也称为**范围锁**这个范围可以跨一个索引记录，多个索引记录，甚至是空的。

**目的**：使用间隙锁可以防止其他事物在这个范围内插入或修改记录。从而保证两次读取这个范围内的记录不会变，进而解决幻读现象。

因为不像记录锁，仅仅只锁一行，其肯能锁多个，所以会增加数据库的开销。虽然解决了幻读问题，但是数据库的并发型一样受到了影响。所以在选择数据库的隔离级别的时候，需要注意权衡性能和并发性。根据实际情况考虑是否需要使用间隙锁。

```sql
mysql> udpate accouts set level = 100 where id = 5;
```

回到这个例子，这个 SQL 语句在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id = 5 前后两个索引之间加上间隙锁。

值得注意的是，间隙锁和间隙锁之间是互不冲突的，间隙锁唯一的作用就是为了防止其他事务的插入，所以加间隙 S 锁和加间隙 X 锁没有任何区别。



### Next-Key Locks

是**记录锁**+**间隙锁**的组合。

假设一个索引包含10、11、13、20这几个值，可能的Next-key锁如下：

- $(-\infty, 10]$
- $(10, 11]$
- $(11, 13]$
- $(13, 20]$
- $(20, +\infty）$

左闭右开的模式，最后一个是间隙锁。同理，在RC模式下是没有`Next-Key`锁的，只有RR隔离级别才有。

```sql
mysql> udpate accouts set level = 100 where id = 5;
```

如果 id 不是主键，而是二级索引，且不是唯一索引，那么这个 SQL 在 RR 隔离级别下会加什么锁呢？答案就是 Next-key 锁，如下：

* $(a, 5]$
* $(5, b)$

其中a,b是id=5的前后两个索引。假设a=1，b=10。那么此时如果插入一条 id = 3 的记录将会阻塞住。之所以要把 id = 5 前后的间隙都锁住，仍然是为了解决幻读问题，因为 id 是非唯一索引，所以 id = 5 可能会有多条记录，为了防止再插入一条 id = 5 的记录，必须将下面标记 ^ 的位置都锁住，因为这些位置都可能再插入一条 id = 5 的记录：

1 ^ 5 ^ 5 ^ 5 ^ 10 11 13 15

可以看出来，Next-key 锁确实可以避免幻读，但是带来的副作用是连插入 id = 3 这样的记录也被阻塞了，这根本就不会引起幻读问题的。

### 插入意向锁

[**插入意向锁**](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-insert-intention-locks) 是一种特殊的间隙锁（所以有的地方把它简写成 II GAP），这个锁表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混淆了。插入意向锁和插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。譬如在上面的例子中，id = 1 和 id = 5 之间如果有两个事务要同时分别插入 id = 2 和 id = 3 是没问题的，虽然两个事务都会在 id = 1 和 id = 5 之间加上插入意向锁，但是不会冲突。

插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，那么间隙锁是如何防止幻读的呢？正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。

