---
title: mysql索引
date: 2020-03-17 16:55:15
tags: mysql索引
categories: mysql 
thumbnail: https://i.loli.net/2020/03/11/7mPyuYUE3w8bKf6.png
---

# 索引

索引的出现其实就是为了提高数据查询的效率，就像书的目录一样， 其是一个**数据结构**, **用于帮助我们在大量数据中快速定位到我们想要查找的数据**

<!--more-->

## 常见模型

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，三种常见、也比较简单的数据结构，它们分别是`哈希表`、`有序数组`和`搜索树`。

1. hash索引
   
   1. 底层为hash表
   
2. B+树索引
   1. 底层为B+树
   2. 演变
      1. 有序数组
      2. 二叉搜索树
      3. 平衡二叉搜索树
      4. B树
      5. B+树
         1. 为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按照键值的大小顺序存放在同一层的叶子结点上
         2. 一个节点内有多个数据集，每个节点大小为一页，==页内==都通过一个双向链表进行链接
   
3. 全文检

   倒排索引

### 哈希表

**哈希表这种结构适用于只有等值查询的场景**比如 Memcached 及其他一些 NoSQL 引擎。

无序，所以不适用于做区间查询

> InnoDB中，支持的哈希索引是自适应的，会根据表的使用情况自动为表生成hash索引，==不能人为的干预一张表中生成的hash索引。==



### 搜索树

解决了因插入元素而导致的移动过多的元素。譬如`BST` `AVL树` `红黑树` `B+树`

#### 有序数组

使用有序数组来实现索引，可以做到查找时间在O（1）的时间复杂度。但是对于数据库的频繁插入与删除，有序数组因为每次删除/插入元素导致的大量的元素移动操作，会使得效率很低。

#### 二叉搜索树

二叉搜索树的可以实现查询O(logN)的时间复杂度。同时其插入操作不会带来大量的元素移动操作。

不过，还是因为频繁的插入删除操作，后期会使得整个二叉搜索树近似为一个链表。从而导致查找的时间大幅提高。

#### 平衡二叉搜索树

平衡二叉树在每次的插入/删除之后，都会进行旋转操作（左旋、右旋、左右旋、右左旋转）维护整颗树的平衡。不过因为其过于严苛的平衡条件，所以维护一棵平衡二叉树还是需要一些消耗的。不过因为其主要用于内存的对象，所以维护的开销相比较小。不过对于MySQL而言，因为数据存储与磁盘中，内存和磁盘读写速度的巨大差距，这也就使得平衡二叉树不适用于索引的实现。

> 这里其实还可以提一下红黑树，因为红黑树相比于二叉搜索树平衡条件不是那么严苛。

不采用红黑树和平衡二叉搜索树实现索引，还有一方面的原因就是每个节点存储的数据过少，只存储一个条数据。本身磁盘和内存的速度差异就很大，每次内存需要向磁盘读取数据时，我们肯定是希望每次读取一页（读取以页为单位）的数据越多越好。

#### B树

上述总结如下：

> ==因为内存的易失性。一般情况下，我们都会选择将表中的数据和索引存储在磁盘这种外围设备中==。但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量**减少从磁盘中读取数据的次数。** **另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。** 如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。 如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。那说明什么？说明每个磁盘块仅仅存储一个键值和数据！那如果我们要存储海量的数据呢？可以想象到二叉树的节点将会非常多，高度也会及其高，我们查找数据时也会进行很多次磁盘IO，我们查找数据的效率将会极低！

这样，B树也就由此出现。B树中每个节点中不仅包含数据的 key 值，还有 data 值。

而每页的存储空间是有限的，如果 data 比较大，会导致每个节点的 key 存储的较少，当数据量较大的时候，同样会导致B树很深，从而增加了磁盘 IO 的次数，进而影响查询效率。

#### B+树（B树的优化）

> B+树，也就是传统意义的索引存储的数据结构，也是目前关系性数据库中查找最为常用且最有效的索引。
>
> B+树的构造类似于二叉树，==根据键值快速查找数据。==

和B树的区别就是其在非叶子结点上，存储都是键值，不会存储数据，数据存储在叶子结点上，同时不同的叶子结点通过链表的形式进行连接。

**小重点：**

B+树索引并不能根据查询条件直接找到对应的记录，找到的是一页的内容，读入内存之后，再在页内进行查找（二分查找），得到具体的数据。

### 全文索引

# 索引的分类

索引基础数据结构介绍完之后，那么在实际中，索引是如何的使用以及有哪些学名

## 从物理实现的角度

### 聚集索引

也可以理解为主键索引。就是按照每张表的主键构造一颗B+树，同时叶子节点存放的是整张表的行列记录数据，同时也将聚集索引的叶子节点称为**数据页**。同B+树的数据结构一样，每个数据页通过一个双向链表进行连接。

### 非聚集索引（辅助索引）

和聚集索引的区别就是，叶子结点存储的是主键的值，而不是记录。

## 从使用功能的角度

### 唯一索引

如果确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候，就应该用关键字UNIQUE把它定义为一个唯一索引，Mysql会在有新纪录插入数据表时，自动检查新纪录的这个字段的值是否已经在某个记录的这个字段里出现过了。如果是，mysql将拒绝插入那条新纪录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，==人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复==

> 索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一

### 普通索引

唯一任务就是为了加快查询速度

### 联合索引

对表上多个列进行索引。

#### 最左匹配原则

在建立联合索引的时候，如何安排索引内的字段顺序。这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

### 前缀索引

大多用于字符串上建立索引

使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。

**使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素。**

> 对于字符串字段上建立索引
>
> 1. 使用前缀索引，不过因为无法使用覆盖索引，所以需要考虑查询字段
> 2. 新加一个字段，可以使用hash对字符串做映射，然后对这个字段建立索引
> 3. 使用reverse（）

### 覆盖索引

属于一种查询的优化，避免非聚集索引的回表操作。

> 定义：通过辅助索引就能够获取查询的结果，而不用再次去查询聚集索引中的记录

**好处：** 辅助索引不包含整条记录的信息，顾其大小远远小于聚集索引，因此大大减少了IO操作。

```sql
-- 实验数据
create table buy_log
(
    userid   int unsigned not null,
    buy_date date         null
);

create index idx_id
    on buy_log (userid);

create index idx_id_date
    on buy_log (userid, buy_date);
```

1. 查询主键信息

   ```sql
   select primiary_key from table where index = 100;
   ```

2. 查询记录数量

   ```sql
   select count(*) from table;
   ```

通常情况下，诸如（a,b）的联合索引是不会选择列b中的查询条件，但是如果是统计操作，并且是覆盖索引，则优化器会走联合索引

```sql
explain select count(*) from buy_log where buy_date >= '2011-01-01' and buy_date <= '2011-02-01';
```



# 一些索引的小事情

这里用于整理一些索引的常见问题

## 建立索引的几大原则

1. 最左匹配原则

   mysql会一直向右匹配知道遇到（>、<、between、like）之后就停止匹配

   > 比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立索引的时候(a,b,c)或(a,c,b)或(b,c,a)可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3. 尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4. **索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。**

   > 例如在字符串对应的索引，使用reverse（）---> key_column = reverse("fafa");

5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

   > ```sql
   > --先删除
   > ALTER` `TABLE` `user``DROP` `INDEX` `idx_user_username;
   > --再以修改后的内容创建同名索引
   > ALTER `TABLE` `user` add `INDEX` `idx_user_username ``ON` `user` `(username(8));
   > ```



## 优化器选择不使用索引情况

**假设：**有orderId聚集索引和order_code 辅助索引；

```sql
explain select order_code from fcl_order where order_code >'1' and order_code < '9000000000000';
```

可以使用辅助索引

**但是：**

```sql
explain select * from fcl_order where order_code >'1'  and order_code < '9000000000000';
explain select * from fcl_order where order_code > '1'
```

看到分析结果，发现并未使用辅助索引，而是执行了全表扫描

用户选取的数据是整行信息，而order_code索引不能覆盖到我们要查询的信息，因此在对order_code索引查询到指定数据后，还要再进行一次书签访问来查找整行的信息。虽然order_code索引中数据是顺序存放的，但是再进行一次书签查找的数据则是无序的，变成了磁盘上的离散读操作。如果访问的数据量很小，那优化器还是会选择辅助索引，但访问的数据占整个表蛮大一部分时（一般20%），优化器会选择通过聚集索引来查找数据，因为顺序读的操作会远大于离散读。

如果==不能使用覆盖索引的情况下==，优化器只有数据量小的时候才会使用辅助索引。这是由传统的机械硬盘特性决定的。若使用固态硬盘，随机读操作很快，且有足够的自信能确认使用辅助索引可以带来更好的性能，可以使用Force index强制使用某个索引。

# MySQL的默认安装路径

1. 如果apt-get命令安装，**安装路径**应在/usr/share/mysql目录下
2. mysqldump文件位置：/usr/bin/mysqldump
3. mysql配置文件:
   /etc/mysql/my.cnf或/usr/share/mysql/my.cnf
4. mysql数据目录在/var/lib/mysql目录下

# References

* [MySQL索引完全解读](http://www.hollischuang.com/archives/4110)
* 极客时间---MySQL45讲
* [MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)



