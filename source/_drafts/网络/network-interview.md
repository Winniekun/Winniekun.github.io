---

title: TCP三次握手四次挥手
date: 2020-04-16 14:44:11
tags: tcp
categories: 网络
thumbnail:
---

# 网络相关基础知识

个人整理的一些经典的网络相关面试题

<!--more-->

**应用层**

* [x] HTTP
* [x] HTTPS

**传输层**

- [x] TCP
- [x] UDP

网络层

* [ ] IP老大哥



# HTTP&HTTPS

## HTTP请求报文段结构和状态码

![image-20210324195150382](/Users/weikunkun/Library/Application Support/typora-user-images/image-20210324195150382.png)

### 请求行

1. 请求方法
2. 请求URL
3. 协议版本

### 请求头

内容多了去了，同时还支持自定义请求头

1. cookies
2. user-agent

### 请求内容

如上图所示

## HTTP响应报文结构

![image-20210324200828674](/Users/weikunkun/Library/Application Support/typora-user-images/image-20210324200828674.png)



### 状态行

#### 常见状态码

1. 2xx

   表示服务器正常响应

2. 3xx

   重定向

   1. 301 永久重定向

      请求资源已经被分配了新的URL

   2. 302 临时重定向

      资源还存在，但暂时需要用另一个URL来访问

3. 4xx

   访问资源不存在

   1. 400

      请求报文有误

   2. 404

      访问资源不存在

   3. 403

      forbidden，禁止访问，可能无权限

4. 5xx

   服务器错误

   1. 500

      内部错误，具体原因未知，不友好，应该返回具体信息

   2. 501

      客户端请求还不支持

   3. 502

      服务器自身无问题，后端逻辑出错

   4. 503

      服务器忙，暂时无法响应

### 首部

1. server

   用于表示服务器安装http应用程序的信息

2. content-type

   响应编码格式

## 保证HTTP传输协议的安全性

**HTTP的缺点**

1. 明文传输

   易造成数据窃取

2. 不验证通讯方的身份

   有可能遭遇伪装

3. 无法证明明文的完整性

   可能已经遭遇篡改，譬如在页面内不添加广告这些。

**通讯加密：**

> 将通信加密，因为HTTP协议没有加密措施，但可以通过SSL/TLS（两个差不多一个东西？）组合使用。从而实现加密http传输的内容

## HTTPS加密过程

**整体来看共分为两个部分**

1. 使用公钥加密（非对称加密方式）方式安全的交换稍后共享密钥加密种要使用的密钥（对层加密的密钥）
2. 使用对称加密进行通信。

**仔细的看这两部分**

公钥证书=数字证书=证书

1. 客户端向服务器发送请求，请求与web服务器建立ssl连接
2. 服务端收到客户请求之后，会将自己的身份信息以证书（包含公钥）的形式发回浏览器
3. 客户端验证证书的合法性。
4. 如果证书受信任，浏览器产生一个**随机密钥（用于对称加密）**，并用服务器的公钥进行加密（非对称加密），使用hash算法对握手信息进行==摘要计算==。**并对摘要对称加密**，将非对称加密的摘要结果和非对称加密的密钥一起发送给服务器
5. 服务器接收到数据之后，使用自己私钥解密出对称加密的密钥，然后对摘要进行解密。然后验证握手消息是否一致。如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器。
6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密

### 非对称加密了解（阐述下RSA的加密流程）



## 输入网址发生的事情

**整体包含如下结果步骤：**

1. 浏览器通过DNS解析出对应的IP地址之后，和对应的服务器建立TCP连接（可以展开进行阐述三次握手过程）
2. 浏览器发送http请求
3. 服务器通过HTTP请求，进行一系列处理
4. 服务器处理完之后，返回一个响应信息（状态行等）
5. 浏览器对响应进行解码、渲染

## 什么是DNS，域名解析过程

用来将方便人们记忆的主机名转化为便于机器处理的IP地址，其协议运行在UDP之上，使用53端口。

### 域名解析过程 a.xxx.com

解析方式有两种：**递归查询**，**递归查询和迭代查询相结合的查询**

递归查询对跟域名服务器的压力太大，所以基本是使用**递归查询和迭代查询相结合的查询**

1. 如果浏览器发现缓存中存有该域名对应的解析IP，在停止解析。如果没有的话，会向本地域名服务器发出请求报文。
2. **本地域名服务器**收到请求后，查询本地缓存，如果没有的话，**以DNS客户端**的身份向**跟域名服务器**发出解析请求的报文
3. **跟域名服务器**收到请求之后，判断该域名属于哪个域：.com、.gov等，然后返回对应的**顶级域名服务器**的IP地址
4. **本地域名服务器**再向**顶级域名服务器**发出请求解析报文。
5. **顶级域名服务器**收到请求之后，判断该域名属于xxx.com域。将该域名对应的**授权域名服务器**的IP地址返回给本地域名服务器。
6. **本地域名服务器**再向**授权域名服务器**发送解析请求报文。
7. **授权域名服务器**收到请求报文之后，将查询的结果返回本地域名服务器
8. 本地域名服务器将查询结果保存到本地缓存，同时返回给客户端





# UDP

**UDP协议是面向无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用层的报文不合并也不拆分，只是添加UDP首部）。支持一对一、一对多、多对一和多对多的交互通信。**

![image-20210323192018014](https://i.loli.net/2021/03/25/yNPHlpLUOmStZ2k.png)

## 如何实现可靠传输

> 以为UDP自身的定位，也就是说明其无法实行可靠传输，所以对于可靠传输的实现，只能从应用层出发。实现方式可以参考tcp可靠传输的方式，只不过实现方式在应用层
>
> 1. 添加seq/ack机制，确保数据发送到对端
> 2. 添加接收、发送缓冲区。
> 3. 添加超时重传机制
>
> > 详细说明：送端发送数据时，生成一个随机seq=x，==然后每一片按照数据大小分配seq==。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据

## TCP和UDP的区别 --- 问答系列

1. TCP是面向连接的，UDP是面向连接的，TCP能够提提供可靠传输、UDP无法提供可靠传输。

   <details>
   <summary>什么叫无连接？</summary>
   <detail>发送数据之前是否要建立连接</detail>
   </details>

   <details>
   <summary>什么叫不可靠，可靠？</summary>
   <detail>UDP接收方收到报文之后，不需要给出任何确认</detail>
   </details>

2. TCP支持点对点通信，UDP支持一对一，一对多，多对一，多对多

3. TCP面向字节流，UDP面向报文

   <details>
   <summary>什么意思？</summary>
   <detail>面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行分发，而UDP一个报文只能一次发完</detail>
   </details>

4. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；
5. TCP首部开销（20字节）比UDP首部开销（8字节）要
6. UDP 的主机不需要维持复杂的连接状态表



<details>
<summary>说了那么多区别，能分别说下，两种传输协议适应的场景吗</summary>
<detail>TCP提供可靠传输，所以对可靠性要求高的，可以使用TCP，譬如http，对于实时性要求较高的，可以选择UDP，比如游戏、媒体通道、直播等，及时出现错误，也能够容忍</detail>
</details>



# TCP

**TCP协议是面向连接的，提供可靠交付，有流量控制、拥塞控制，并且是面向字节流。每一条TCP连接只能是点对点。**

以下是示意图：

![TCP三次握手-四次分手.png](https://i.loli.net/2020/04/17/cCoKZGS9yQWiXY1.png)





## 通过三次握手建立链接

![20191129101827556_21212](https://i.loli.net/2021/03/23/5BvjsrIeanWZPG3.png)

### 三次握手过程

1. 客户端向服务端发起请求连接的**报文段**，其首部的**SYN**标识位被置1，并且还会随机产生一个==*起始序号*==**seq number**，这时客户端进入**SYN_SENT**状态。
2. 服务端收到客户端的请求链接报文段之后，如果确定连接，则会返回一个**确认报文段**，该报文段中**SYN、ACK**标识位被置为1，产生一个**acknowladge number（确认号） = seq number + 1**  并随机产生一个自己的==起始序号== **seq number**。这时服务端进入**SEND_RCVD**状态
3. 客户端收到**确认报文段（ack number = seq + 1 ACK=1）**之后，还需要向服务器**发出确认**。这个**报文段**的**ACK**标识位置1，**acknowledge number =  服务端发送的seq number + 1**。 这时客户端进入**ESTABLISHED**状态。同时服务端收到该报文段之后，自身也进入了**ESTABLISHED**状态。



### 衍生问题

#### TCP报文段包含哪些内容

![image-20210323192041445](https://i.loli.net/2021/03/23/F8BSbU4ZdGaAwIQ.png)

#### 什么是SYN泛洪攻击，如何解决

> 服务器的资源是在==完成第二次握手（SYN_RCVD状态）==的时候分配的，而客户端的资源是在==完成第三次握手（ESTABLISHED）==的时候分配的。这样就使得服务器容易受到SYN泛洪攻击
>
> A（攻击者）发送请求链接报文段（也就是第一次握手），服务器接收到之后，确定链接，返回确认报文段（第二次握手），这个时候，A不再进行确认，这个时候连接处于挂起状态（半连接状态）。超过一段时间之后，服务器端会重新发送确认报文。这样一来就会更加浪费服务器的资源。A就对服务器发送非法大量的这种TCP连接，由于每一个都没法完成握手的机制，所以它就会消耗服务器的==内存==最后可能导致服务器死机，就无法正常工作了。

**解决方式**

1. 降低SYN Timeout时间，使得主机尽快释放==半连接的占用==
2. 采用SYN cookie设置，如果短时间内收到了某个IP的重复SYN请求，我们就认为受到了攻击。我们合理的采用防火墙设置等外部网络也可以进行拦截。

#### TCP建立连接可以两次握手吗？为什么？

不行，主要有两个原因

1. 防止两次握手的情况下，已经失效的连接请求报文段突然又传入到服务端，而产生错误。

   **情形：** 客户端A向服务端B发送请求连接报文段，因为某种原因，请求连接报文段在某个节点滞留，A超时后认为报文段丢失，然后重重新发送请求链接报文段。通过两次握手成功之后，A和B进行通讯，通讯结束之后，断开连接，这时候第一次发送的报文段传递到B，B确认连接之后，向A发送确认报文段。假设是”两次握手“，这时候连接已经建立了。B会一直等待A发送数据，不过这个时候A已经不发送数据了。这样就造成了资源浪费了。如果是“三次握手”，A不发送任何信息，没有再次确认。B由于收不到确认消息，就知道A没有要建立连接

2. 服务端无法确定客户端时候正确收到第二次握手的信息。

#### TCP建立连接可以采用四次握手吗？为什么？

可以，但是不建议，因为会降低传输的效率。

> 四次握手可以理解为，将三次握手中的第二次握手拆分位两次握手， 服务端先 发送 ACK 和  acknowledge number，之后服务端的SYN和seq number 在第三次握手中完成，最后再由客户端给服务端发出确认。

#### 第三次握手中，如果客户端的ACK未送到服务器，会怎样

1. 服务端

   服务端在超时后，会重新发送 SYN + ACK 的确认报文段（默认重发5次，之后自动关闭连接，进入**CLOSED状态**）。客户端收到后会重新发送ACK给服务端。

2. 客户端

   1. 在服务端进行超时重传过程中，如果客户端向服务端发送数据，数据头部的ACK为1，服务端收到之后，读取acknowledge number正确之后，进入**ESTABLISHED**状态
   2. 如果服务端已经进入**CLOSED状态**，如果客户端向服务器发送数据，服务器会以RST包回答。

#### 如果已经建立连接，但是客户端出现故障怎么办？

> 服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个==探测报文段==，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### 什么是序号

> TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的起始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，==B可以确认什么样的数据编号是合法的==；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001（数据长度是1000字节），就说明编号为1001-2000的数据已经被B成功接受。

#### 什么是确认号

表示接收方期望收到发送方的下一个报文段数据的第一个字节序号。

譬如接收方的确认号为N，则表示到序号N-1为止的数据已经被正确收到了。

**举例说明：**

> B正确收到了A发送来的报文段，其序号是501，数据长度是200，则表明B正确收到了字节序号从501-700的数据。因此接下来B期望收到的是A的下一个数据序号701。所以B在返回确认报文段的时候，将确认序号置701。

#### 什么是超时、什么是重传

**超时：**

> TCP每发送一个报文段，就会对这个报文段设置一一次计时器，只要计时器设置的重传时间到期但还没有收到确认，就要重传一次该报文段

两种事件会导致TCP对报文进行重传：**超时和冗余ACK**

**冗余ACK：**

> 触发超时超时重传存在一个问题，就是超时周期往往太长了。发送方通常可以在超时重传发送之前，通过注意冗余的ACK报文段检测==丢包的情况==
>
> 通俗来讲冗余ACK就是再次确认某个报文段的ACK，而发送方已经收到过该报文段的确认。
>
> 举例说明：
>
> > 发送方A发送了序号1，2，3，4，5的TCP报文段，其中2号报文段丢失在链路中，无法被接收方B收到。此时3，4，5号报文段对于B来说就成了失序报文段。**TCP规定每当比期望号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号**
> >
> > 虽然B收到了3，4，5的报文段，但是不是B期望的下一个报文，于是B发送3个对1号报文冗余的ACK。表示自己期望收到2号报文段
> >
> > **TCP规定当接收方收到对同一个报文段的3个冗余ACK，则可以视为跟在这个被确认报文段之后的报文段已经丢失**

通过**冗余ACK**进行的重传称为==快重传==



## 通过四次挥手断开链接

![20191129112652915_15481](https://i.loli.net/2021/03/23/f1m2CniZ73zShFt.png)

1. 第一次挥手：客户端准备关闭连接，就向服务端发送一个**FIN 标识位=1的连接释放报文段**，并停止发送数据，**主动关闭**TCP连接。同时该报文段的**seqnumber = M**（它是前面已经传输的数据最后一个字节的序号+1）。这时客户端进入**FIN_WAIT_1状态**

2. 第二次挥手：服务端收到客户端**连接释放报文段**后就发送确认。该报文段内容： **ACK**标识位置1 **acknowledge number（确认号）= M + 1** 这时服务端进入**CLOSE WAIT状态（半关闭状态）**

3. 第三次挥手：如果服务器已经没有要发送的数据，也会发送一个**FIN=1的连接释放报文段**。同时也包含有一个**seq number = N** 这时服务端进入**LAST_ACK状态**

4. 第四次挥手：客户端收到服务器的**连接释放报文段后**，进入**TIME_WAIT**状态，同时还需要向服务端发出确认，在该报文段中， **ACK**标识位置1， **acknowledge number = 服务端的seq number  + 1** 。服务端收到后，确认**acknowledge number**后，进入**CLOSED状态**，不再向客户端发送数据。客户端等待**2MSL（报文段最长寿命）**时间后，也进入**CLOSED状态**。完成四次挥手

   > 客户端进入cloesed状态比服务端晚

### 衍生问题

#### 为什么不能把服务端发送的ACK 和 FIN 合并起来，变成三次挥手（CLOSE_WAIT状态的意义是什么）

因为，服务端收到客户端的连接释放报文段之后，可能还有一些数据是需要向客户端发送，这时先回复ACK，表示接受到了释放连接的请求。等到数据发送完毕之后，再发送FIN，断开服务端和客户端的数据传输

> TCP是全双工通信，可以理解为两条数据通路。当发送FIN=1的报文段之后，发送方就不能再发送数据了，也就是关闭了一条通路。但是对方还是可以发送数据

#### 第二次挥手时，服务器的ACK报文段没有送达客户端，会怎么样？

客户端没有收到ACK确认，会重新发送FIN请求。

#### 客户端TIME_WAIT状态的意义什么是（为什么要等待2MSL（最长报文寿命））？

1. 保证客户端发送的最后一个确认报文段能够到达服务端。如果客户端最后确认的报文段丢失，则服务端不能进入**正常closed状态**，但是此时客户端已经关闭了，也不能再次重传了。

2. 防止出现**已失效的连接请求报文段**。 客户端在发送最后一个确认报文段后，再经过2MSL时间之后，可以确保本连接持续的时间内所产生的所有报文段从网络中消失。是的下一个新的连接不会出现旧的连接请求。

   <img src="https://i.loli.net/2021/05/06/JBEj9nyt4wUmSPY.png" alt="image-20210506202604968" style="zoom: 33%;" />

MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。



#### 如何处理大量的TIME_WAIT或CLOSE_WAIT

这种情况比较常见，一些爬虫服务器或者WEB服务器（如果网管在安装的时候没有做内核参数优化的话）上经常会遇到这个问题，这个问题是怎么产生的呢？

TIME_WAIT是主动关闭连接的一方保持的状态，对于爬虫服务器来说他本身就是“客户端”，在完成一个爬取任务之后，他就会发起主动关闭连接，从而进入TIME_WAIT的状态，然后在保持这个状态2MSL（max segment lifetime）时间之后，彻底关闭回收资源。为什么要这么做？明明就已经主动关闭连接了为啥还要保持资源一段时间呢？这个是TCP/IP的设计者规定的，主要出于以下两个方面的考虑：

1.防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）
2.可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。另外这么设计TIME_WAIT 会定时的回收资源，并不会占用很大资源的，除非短时间内接受大量请求或者受到攻击。

解决思路很简单，就是让**服务器能够快速回收和重用那些TIME_WAIT的资源**。



**TIME_WAIT状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的。**

但是CLOSE_WAIT就不一样了，如果一直保持在CLOSE_WAIT状态，**那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。**个人觉得这种情况，通过服务器内核参数也没办法解决，服务器对于程序抢占的资源没有主动回收的权利，除非终止程序运行。

如果你使用的是HttpClient并且你遇到了大量CLOSE_WAIT的情况，那么这篇日志也许对你有用：http://blog.csdn.net/shootyou/article/details/6615051

在那边日志里头我举了个场景，来说明CLOSE_WAIT和TIME_WAIT的区别，这里重新描述一下：

服务器A是一台爬虫服务器，它使用简单的HttpClient去请求资源服务器B上面的apache获取文件资源，正常情况下，如果请求成功，那么在抓取完资源后，服务器A会主动发出关闭连接的请求，这个时候就是主动关闭连接，服务器A的连接状态我们可以看到是TIME_WAIT。如果一旦发生异常呢？假设请求的资源服务器B上并不存在，那么这个时候就会由服务器B发出关闭连接的请求，服务器A就是被动的关闭了连接，**如果服务器A被动关闭连接之后程序员忘了让HttpClient释放连接，那就会造成CLOSE_WAIT的状态了**。




所以如果将大量CLOSE_WAIT的解决办法总结为一句话那就是：查代码。因为问题出在服务器程序里头啊。

## TCP流量控制

#### 目的

通过流量控制用来消除发送方使得接收方缓存区溢出的可能性。所以流量控制也可以说是一种速度匹配服务（匹配发送方的发送速率和接收方的读取速率）

#### 实现方式

通过滑动窗口实现流量控制

> 在通信过程中，有效的数据只从A发向B，而B仅向A发送确认报文，这时B就可以通过设置确认报文段首部的窗口字段来将rwnd（接收方允许连续接收的最大能力）通知给发送方A。发送A根据最新收到的rwnd值来限制自己的窗口大小。这样可以将确认的数量控制在rwnd大小内。保证了A不会使B的接收缓存溢出。当然A的窗口大小实际是取Math.min(rwnd, cwnd)
>
> 1. rwnd（接收窗口）
>
>    接收方根据目前接收缓存大小所声明的最新的窗口值，反映了接收方的接收能力，由接收方通过确认报文段的首部的窗口字段通知发送方
>
> 2. cwnd（拥塞窗口）
>
>    发送方根据自身估算的网络拥塞程度所设置的窗口大小。反映了当时的网络容量。网络流畅增大一些，拥挤减少一些。

## TCP拥塞控制

防止过多的数据注入到网络中，减轻网络中路由器和链路的过载。

为了更好的对传输层进行拥塞控制，因特网建议标准定义了以下四种算法：**慢开始，拥塞避免，快重传，快恢复**

### 慢开始和拥塞避免

#### 慢开始

建立连接之后，开始发送TCP报文段时，先令拥塞窗口cwnd=1 （**一个最大的报文段长度MSS**），而在每次收到一个对新的报文段的确认之后，将cwnd加1，用这种逐步增大的发送方的拥塞窗口，可以使分组注入到网络的速率更加合理。

使用慢开始算法，每经过一次==传输轮次==（RTT）拥塞窗口就会加倍，也就是说rwnd在慢开始阶段呈指数级增长。直到慢开始算法将拥塞窗口增大到一个规定的==慢开始门限ssthresh（阈值）==该用**拥塞避免算法**

#### 拥塞避免

发送端的cwnd大小每经过一个==传输轮次==，就增加一个==MSS（一个最大的报文段长度）==，而不是加倍（称之为==加法增大==），当出现一次超时（网络拥塞时），令慢开始的门限（阈值）为当前cwnd的一半。（乘法减小）

1. cwnd < ssthresh，使用慢开始算法
2. cwnd > ssthresh，使用拥塞避免算法
3. cwnd = ssthresh，使用慢开始或拥塞避免均可（一般为拥塞避免）

#### 网络拥塞时的处理

出现拥塞之后，**无论是慢开始还是拥塞避免阶段**，都要将慢开始的门限（阈值）变为出现拥塞时cwnd的一半（不能小于2），然后重新开始传输，开始传输时的cwnd的大小重新置1。

**目的：**

> 能够迅速减少主机发送到网络中的分组数量，进而确保发生拥塞的路由器能够有足够的时间把队列中积压的分组处理好

![image-20210323221145510](https://i.loli.net/2021/03/23/KClEbvGIxwykHq3.png)

### 快重传和快恢复

![image-20210323221810570](https://i.loli.net/2021/03/23/uqnkAyDZ8JXi2bY.png)

#### 快重传

上述中讲过了快重传的机制，通过快重传可以更早的==重传丢失的报文段==。

当发送方连续收到三个重复的ack的时候，直接重传对方尚未接受的报文段，而不必等待超时之后再重传。

#### 快恢复

当发送发接收到三次冗余ACK之后，就执行==乘法减小==，把慢开始的门限（阈值）设置为出现拥塞时发送方cwnd的一半。

但是和慢开始不同的是，接下来继续传输时，不是将cwnd置1MSS，而是将cwnd置为乘法减小后的==慢开始的门限（阈值）ssthresh==

**因为跳过了cwnd从1开始的慢开始过程，所以称之为快恢复**



# IP老大哥

子网掩码，子网划分

# references

* [UDP如何实现可靠传输](https://www.jianshu.com/p/6c73a4585eba)

- 王道计算机网络2019版本
- [Waking-Up](https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md)